# 4.2 代码审查和优化

## 学习目标
- 掌握TypeScript代码审查的最佳实践
- 理解类型安全和性能优化技巧
- 学会识别和修复常见的类型问题
- 掌握代码重构和优化策略
- 培养高质量的TypeScript编程习惯

## 学习内容

### 1. 代码审查最佳实践

#### 1.1 类型安全审查
```typescript
// ❌ 问题代码示例
function processUserData(data: any) {
  return {
    name: data.name.toUpperCase(),
    age: data.age + 1,
    email: data.email.toLowerCase()
  };
}

// ✅ 改进后的代码
interface UserData {
  name: string;
  age: number;
  email: string;
}

function processUserData(data: UserData): ProcessedUserData {
  return {
    name: data.name.toUpperCase(),
    age: data.age + 1,
    email: data.email.toLowerCase()
  };
}

interface ProcessedUserData {
  name: string;
  age: number;
  email: string;
}
```

#### 1.2 类型守卫审查
```typescript
// ❌ 不安全的类型检查
function isString(value: unknown): boolean {
  return typeof value === 'string';
}

function processValue(value: unknown) {
  if (isString(value)) {
    // 这里 value 仍然是 unknown 类型
    console.log(value.length); // 类型错误
  }
}

// ✅ 正确的类型守卫
function isString(value: unknown): value is string {
  return typeof value === 'string';
}

function processValue(value: unknown) {
  if (isString(value)) {
    // 这里 value 被正确推断为 string 类型
    console.log(value.length); // 类型安全
  }
}
```

#### 1.3 泛型使用审查
```typescript
// ❌ 过度使用 any
function createArray(length: number, value: any): any[] {
  return Array(length).fill(value);
}

// ✅ 使用泛型提供类型安全
function createArray<T>(length: number, value: T): T[] {
  return Array(length).fill(value);
}

// 使用示例
const stringArray = createArray(3, 'hello'); // string[]
const numberArray = createArray(3, 42); // number[]
```

### 2. 性能优化技巧

#### 2.1 类型推断优化
```typescript
// ❌ 不必要的类型注解
const users: Array<{ name: string; age: number }> = [
  { name: 'John', age: 30 },
  { name: 'Jane', age: 25 }
];

// ✅ 让TypeScript推断类型
const users = [
  { name: 'John', age: 30 },
  { name: 'Jane', age: 25 }
]; // 类型自动推断为 { name: string; age: number }[]
```

#### 2.2 条件类型优化
```typescript
// ❌ 复杂的条件逻辑
type ApiResponse<T> = T extends string 
  ? { message: T } 
  : T extends number 
  ? { count: T } 
  : { data: T };

// ✅ 使用映射类型简化
type ApiResponse<T> = {
  [K in keyof T]: T[K];
} & {
  success: boolean;
  timestamp: Date;
};
```

#### 2.3 工具类型优化
```typescript
// ❌ 重复的类型定义
interface User {
  id: string;
  name: string;
  email: string;
  createdAt: Date;
  updatedAt: Date;
}

interface CreateUserRequest {
  name: string;
  email: string;
}

interface UpdateUserRequest {
  name?: string;
  email?: string;
}

// ✅ 使用工具类型减少重复
interface User {
  id: string;
  name: string;
  email: string;
  createdAt: Date;
  updatedAt: Date;
}

type CreateUserRequest = Omit<User, 'id' | 'createdAt' | 'updatedAt'>;
type UpdateUserRequest = Partial<Omit<User, 'id' | 'createdAt' | 'updatedAt'>>;
```

### 3. 常见类型问题识别

#### 3.1 类型断言滥用
```typescript
// ❌ 危险的类型断言
const userInput = document.getElementById('username') as HTMLInputElement;
const value = userInput.value; // 可能为 null

// ✅ 安全的类型守卫
function getInputElement(id: string): HTMLInputElement | null {
  const element = document.getElementById(id);
  return element instanceof HTMLInputElement ? element : null;
}

const userInput = getInputElement('username');
if (userInput) {
  const value = userInput.value; // 类型安全
}
```

#### 3.2 联合类型处理
```typescript
// ❌ 不完整的联合类型处理
function processValue(value: string | number) {
  if (typeof value === 'string') {
    return value.toUpperCase();
  }
  // 缺少 number 类型的处理
}

// ✅ 完整的联合类型处理
function processValue(value: string | number): string {
  if (typeof value === 'string') {
    return value.toUpperCase();
  }
  return value.toString();
}
```

#### 3.3 可选属性处理
```typescript
// ❌ 不安全的可选属性访问
interface User {
  name: string;
  email?: string;
}

function getUserEmail(user: User): string {
  return user.email.toLowerCase(); // 可能为 undefined
}

// ✅ 安全的可选属性处理
function getUserEmail(user: User): string | undefined {
  return user.email?.toLowerCase();
}

// 或者使用类型守卫
function getUserEmail(user: User): string {
  if (user.email) {
    return user.email.toLowerCase();
  }
  throw new Error('User email is required');
}
```

### 4. 代码重构策略

#### 4.1 提取公共类型
```typescript
// ❌ 重复的类型定义
interface User {
  id: string;
  name: string;
  email: string;
  createdAt: Date;
  updatedAt: Date;
}

interface Task {
  id: string;
  title: string;
  description: string;
  createdAt: Date;
  updatedAt: Date;
}

// ✅ 提取公共基础类型
interface BaseEntity {
  id: string;
  createdAt: Date;
  updatedAt: Date;
}

interface User extends BaseEntity {
  name: string;
  email: string;
}

interface Task extends BaseEntity {
  title: string;
  description: string;
}
```

#### 4.2 使用映射类型
```typescript
// ❌ 手动定义多个相似类型
interface User {
  name: string;
  email: string;
  age: number;
}

interface UserForm {
  name: string;
  email: string;
  age: string; // 表单中的数字通常是字符串
}

interface UserDisplay {
  name: string;
  email: string;
  age: string;
}

// ✅ 使用映射类型
interface User {
  name: string;
  email: string;
  age: number;
}

type UserForm = {
  [K in keyof User]: string;
};

type UserDisplay = {
  [K in keyof User]: string;
};
```

#### 4.3 条件类型重构
```typescript
// ❌ 复杂的条件逻辑
type ApiResponse<T> = T extends string 
  ? { message: T } 
  : T extends number 
  ? { count: T } 
  : T extends boolean 
  ? { success: T } 
  : { data: T };

// ✅ 使用联合类型简化
type ApiResponse<T> = 
  | { message: string }
  | { count: number }
  | { success: boolean }
  | { data: T };
```

### 5. 测试和验证

#### 5.1 类型测试
```typescript
// 类型测试示例
type Expect<T extends true> = T;
type Equal<X, Y> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2 ? true : false;

// 测试类型推断
type Test1 = Expect<Equal<ReturnType<typeof createArray<string>>, string[]>>;
type Test2 = Expect<Equal<Parameters<typeof processValue>, [string | number]>>;

// 测试工具类型
type Test3 = Expect<Equal<Partial<User>, { name?: string; email?: string; age?: number }>>;
type Test4 = Expect<Equal<Pick<User, 'name'>, { name: string }>>;
```

#### 5.2 运行时类型验证
```typescript
// 使用 Zod 进行运行时验证
import { z } from 'zod';

const UserSchema = z.object({
  name: z.string(),
  email: z.string().email(),
  age: z.number().min(0).max(120)
});

type User = z.infer<typeof UserSchema>;

function validateUser(data: unknown): User {
  return UserSchema.parse(data);
}

// 使用示例
try {
  const user = validateUser({ name: 'John', email: 'john@example.com', age: 30 });
  // user 的类型是 User
} catch (error) {
  // 处理验证错误
  console.error('Invalid user data:', error);
}
```

### 6. 代码质量工具

#### 6.1 ESLint 配置
```json
{
  "extends": [
    "@typescript-eslint/recommended",
    "@typescript-eslint/recommended-requiring-type-checking"
  ],
  "rules": {
    "@typescript-eslint/no-explicit-any": "error",
    "@typescript-eslint/no-unused-vars": "error",
    "@typescript-eslint/explicit-function-return-type": "warn",
    "@typescript-eslint/no-non-null-assertion": "error",
    "@typescript-eslint/prefer-nullish-coalescing": "error",
    "@typescript-eslint/prefer-optional-chain": "error"
  }
}
```

#### 6.2 TypeScript 严格配置
```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictBindCallApply": true,
    "strictPropertyInitialization": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true
  }
}
```

## 实践练习

### 练习1：代码审查
```typescript
// 任务：审查以下代码并指出问题
interface ApiResponse<T> {
  data: T;
  status: number;
  message: string;
}

function processApiResponse<T>(response: ApiResponse<T>): T {
  if (response.status === 200) {
    return response.data;
  }
  throw new Error(response.message);
}

// 问题：
// 1. 缺少错误处理
// 2. 类型定义不够严格
// 3. 缺少输入验证

// 你的改进方案
```

### 练习2：性能优化
```typescript
// 任务：优化以下代码的性能
function processUsers(users: any[]) {
  return users.map(user => ({
    id: user.id,
    name: user.name,
    email: user.email,
    isActive: user.status === 'active'
  }));
}

// 优化点：
// 1. 使用泛型
// 2. 添加类型定义
// 3. 优化类型推断

// 你的优化方案
```

### 练习3：类型安全重构
```typescript
// 任务：重构以下代码使其类型安全
function getUserData(id: string) {
  const user = database.findUser(id);
  if (user) {
    return {
      name: user.name,
      email: user.email,
      age: user.age
    };
  }
  return null;
}

// 重构要求：
// 1. 添加类型定义
// 2. 使用类型守卫
// 3. 处理边界情况

// 你的重构方案
```

## 学习检查点

- [ ] 能够识别常见的类型问题
- [ ] 掌握代码审查的最佳实践
- [ ] 理解性能优化技巧
- [ ] 能够进行有效的代码重构
- [ ] 掌握类型测试方法

## 下一步学习

完成本部分学习后，请继续学习 [4.3 阶段总结](./4.3-stage-summary.md)。



