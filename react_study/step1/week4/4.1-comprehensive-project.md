# 4.1 综合项目：TypeScript 5.x 现代类型系统实战

## 项目目标
- 综合运用TypeScript 5.x的所有核心特性
- 实践现代类型系统编程技巧
- 构建企业级类型安全的应用程序
- 掌握类型级编程和元编程技术

## 项目概述

### 项目名称：智能任务管理系统 (Smart Task Management System)

一个功能完整的任务管理系统，包含用户管理、任务创建、团队协作、权限控制、数据验证等核心功能。项目将全面展示TypeScript 5.x现代类型系统的强大能力。

### 技术栈
- **TypeScript 5.x** - 现代类型系统
- **Node.js** - 运行时环境
- **Express.js** - Web框架
- **MongoDB** - 数据库
- **Jest** - 测试框架
- **ESLint + Prettier** - 代码质量工具

## 项目结构

```
smart-task-management/
├── src/
│   ├── types/
│   │   ├── core.ts           # 核心类型定义
│   │   ├── user.ts           # 用户相关类型
│   │   ├── task.ts           # 任务相关类型
│   │   ├── team.ts           # 团队相关类型
│   │   ├── permission.ts     # 权限相关类型
│   │   └── api.ts            # API相关类型
│   ├── utils/
│   │   ├── type-guards.ts    # 类型守卫
│   │   ├── validators.ts     # 验证工具
│   │   ├── transformers.ts   # 数据转换
│   │   └── helpers.ts        # 辅助工具
│   ├── services/
│   │   ├── userService.ts    # 用户服务
│   │   ├── taskService.ts    # 任务服务
│   │   ├── teamService.ts    # 团队服务
│   │   └── permissionService.ts # 权限服务
│   ├── middleware/
│   │   ├── auth.ts           # 认证中间件
│   │   ├── validation.ts     # 验证中间件
│   │   └── permission.ts     # 权限中间件
│   ├── controllers/
│   │   ├── userController.ts # 用户控制器
│   │   ├── taskController.ts # 任务控制器
│   │   └── teamController.ts # 团队控制器
│   ├── routes/
│   │   ├── userRoutes.ts     # 用户路由
│   │   ├── taskRoutes.ts     # 任务路由
│   │   └── teamRoutes.ts     # 团队路由
│   └── app.ts                # 应用入口
├── tests/
│   ├── unit/                 # 单元测试
│   ├── integration/          # 集成测试
│   └── type-tests/           # 类型测试
├── docs/                     # 文档
├── package.json
├── tsconfig.json
└── README.md
```

## 核心功能模块

### 1. 用户管理系统

#### 1.1 用户类型定义
```typescript
// src/types/user.ts
export enum UserRole {
  ADMIN = 'admin',
  MANAGER = 'manager',
  MEMBER = 'member',
  GUEST = 'guest'
}

export enum UserStatus {
  ACTIVE = 'active',
  INACTIVE = 'inactive',
  SUSPENDED = 'suspended',
  PENDING = 'pending'
}

export interface User {
  id: string;
  email: string;
  username: string;
  firstName: string;
  lastName: string;
  role: UserRole;
  status: UserStatus;
  avatar?: string;
  preferences: UserPreferences;
  createdAt: Date;
  updatedAt: Date;
  lastLoginAt?: Date;
}

export interface UserPreferences {
  theme: 'light' | 'dark' | 'auto';
  language: 'en' | 'zh' | 'es' | 'fr';
  notifications: NotificationSettings;
  timezone: string;
}

export interface NotificationSettings {
  email: boolean;
  push: boolean;
  sms: boolean;
  taskUpdates: boolean;
  teamUpdates: boolean;
  deadlineReminders: boolean;
}

// 用户创建和更新类型
export type CreateUserInput = Omit<User, 'id' | 'createdAt' | 'updatedAt' | 'lastLoginAt'>;
export type UpdateUserInput = Partial<Omit<CreateUserInput, 'email'>>;
export type UserProfile = Pick<User, 'id' | 'username' | 'firstName' | 'lastName' | 'avatar' | 'role'>;

// 用户查询选项
export interface UserQueryOptions {
  role?: UserRole;
  status?: UserStatus;
  search?: string;
  sortBy?: keyof User;
  sortOrder?: 'asc' | 'desc';
  limit?: number;
  offset?: number;
}
```

#### 1.2 用户服务实现
```typescript
// src/services/userService.ts
import { User, CreateUserInput, UpdateUserInput, UserQueryOptions, UserRole } from '../types/user';
import { ApiResponse, PaginatedResponse } from '../types/api';
import { validateEmail, validatePassword } from '../utils/validators';

export interface UserService {
  createUser(input: CreateUserInput): Promise<ApiResponse<User>>;
  getUserById(id: string): Promise<ApiResponse<User>>;
  updateUser(id: string, input: UpdateUserInput): Promise<ApiResponse<User>>;
  deleteUser(id: string): Promise<ApiResponse<void>>;
  getUsers(options: UserQueryOptions): Promise<ApiResponse<PaginatedResponse<User>>>;
  changeUserRole(id: string, role: UserRole): Promise<ApiResponse<User>>;
  searchUsers(query: string): Promise<ApiResponse<User[]>>;
}

export class UserServiceImpl implements UserService {
  private users: Map<string, User> = new Map();

  async createUser(input: CreateUserInput): Promise<ApiResponse<User>> {
    try {
      // 验证输入数据
      if (!validateEmail(input.email)) {
        return {
          success: false,
          error: { code: 'INVALID_EMAIL', message: 'Invalid email format' }
        };
      }

      if (!validatePassword(input.username)) {
        return {
          success: false,
          error: { code: 'INVALID_USERNAME', message: 'Invalid username format' }
        };
      }

      // 检查用户是否已存在
      const existingUser = Array.from(this.users.values()).find(
        user => user.email === input.email || user.username === input.username
      );

      if (existingUser) {
        return {
          success: false,
          error: { code: 'USER_EXISTS', message: 'User already exists' }
        };
      }

      // 创建新用户
      const user: User = {
        ...input,
        id: this.generateId(),
        createdAt: new Date(),
        updatedAt: new Date()
      };

      this.users.set(user.id, user);

      return {
        success: true,
        data: user
      };
    } catch (error) {
      return {
        success: false,
        error: { code: 'INTERNAL_ERROR', message: 'Failed to create user' }
      };
    }
  }

  async getUserById(id: string): Promise<ApiResponse<User>> {
    const user = this.users.get(id);
    if (!user) {
      return {
        success: false,
        error: { code: 'USER_NOT_FOUND', message: 'User not found' }
      };
    }

    return {
      success: true,
      data: user
    };
  }

  async updateUser(id: string, input: UpdateUserInput): Promise<ApiResponse<User>> {
    const user = this.users.get(id);
    if (!user) {
      return {
        success: false,
        error: { code: 'USER_NOT_FOUND', message: 'User not found' }
      };
    }

    const updatedUser: User = {
      ...user,
      ...input,
      updatedAt: new Date()
    };

    this.users.set(id, updatedUser);

    return {
      success: true,
      data: updatedUser
    };
  }

  async deleteUser(id: string): Promise<ApiResponse<void>> {
    if (!this.users.has(id)) {
      return {
        success: false,
        error: { code: 'USER_NOT_FOUND', message: 'User not found' }
      };
    }

    this.users.delete(id);

    return {
      success: true,
      data: undefined
    };
  }

  async getUsers(options: UserQueryOptions): Promise<ApiResponse<PaginatedResponse<User>>> {
    let users = Array.from(this.users.values());

    // 应用过滤器
    if (options.role) {
      users = users.filter(user => user.role === options.role);
    }

    if (options.status) {
      users = users.filter(user => user.status === options.status);
    }

    if (options.search) {
      const searchLower = options.search.toLowerCase();
      users = users.filter(user => 
        user.firstName.toLowerCase().includes(searchLower) ||
        user.lastName.toLowerCase().includes(searchLower) ||
        user.email.toLowerCase().includes(searchLower) ||
        user.username.toLowerCase().includes(searchLower)
      );
    }

    // 应用排序
    if (options.sortBy) {
      users.sort((a, b) => {
        const aValue = a[options.sortBy!];
        const bValue = b[options.sortBy!];
        
        if (aValue < bValue) return options.sortOrder === 'desc' ? 1 : -1;
        if (aValue > bValue) return options.sortOrder === 'desc' ? -1 : 1;
        return 0;
      });
    }

    // 应用分页
    const limit = options.limit || 10;
    const offset = options.offset || 0;
    const paginatedUsers = users.slice(offset, offset + limit);

    return {
      success: true,
      data: {
        items: paginatedUsers,
        total: users.length,
        limit,
        offset,
        hasMore: offset + limit < users.length
      }
    };
  }

  async changeUserRole(id: string, role: UserRole): Promise<ApiResponse<User>> {
    const user = this.users.get(id);
    if (!user) {
      return {
        success: false,
        error: { code: 'USER_NOT_FOUND', message: 'User not found' }
      };
    }

    const updatedUser: User = {
      ...user,
      role,
      updatedAt: new Date()
    };

    this.users.set(id, updatedUser);

    return {
      success: true,
      data: updatedUser
    };
  }

  async searchUsers(query: string): Promise<ApiResponse<User[]>> {
    const searchLower = query.toLowerCase();
    const results = Array.from(this.users.values()).filter(user =>
      user.firstName.toLowerCase().includes(searchLower) ||
      user.lastName.toLowerCase().includes(searchLower) ||
      user.email.toLowerCase().includes(searchLower) ||
      user.username.toLowerCase().includes(searchLower)
    );

    return {
      success: true,
      data: results
    };
  }

  private generateId(): string {
    return Math.random().toString(36).substr(2, 9);
  }
}
```

### 2. 任务管理系统

#### 2.1 任务类型定义
```typescript
// src/types/task.ts
export enum TaskStatus {
  TODO = 'todo',
  IN_PROGRESS = 'in_progress',
  REVIEW = 'review',
  DONE = 'done',
  CANCELLED = 'cancelled'
}

export enum TaskPriority {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  URGENT = 'urgent'
}

export enum TaskType {
  FEATURE = 'feature',
  BUG = 'bug',
  IMPROVEMENT = 'improvement',
  DOCUMENTATION = 'documentation',
  TEST = 'test'
}

export interface Task {
  id: string;
  title: string;
  description: string;
  status: TaskStatus;
  priority: TaskPriority;
  type: TaskType;
  assigneeId: string;
  reporterId: string;
  teamId: string;
  projectId: string;
  tags: string[];
  dueDate?: Date;
  estimatedHours?: number;
  actualHours?: number;
  dependencies: string[];
  subtasks: string[];
  attachments: Attachment[];
  comments: Comment[];
  createdAt: Date;
  updatedAt: Date;
  completedAt?: Date;
}

export interface Attachment {
  id: string;
  filename: string;
  originalName: string;
  mimeType: string;
  size: number;
  url: string;
  uploadedBy: string;
  uploadedAt: Date;
}

export interface Comment {
  id: string;
  content: string;
  authorId: string;
  createdAt: Date;
  updatedAt: Date;
  isEdited: boolean;
}

// 任务创建和更新类型
export type CreateTaskInput = Omit<Task, 'id' | 'createdAt' | 'updatedAt' | 'completedAt' | 'attachments' | 'comments'>;
export type UpdateTaskInput = Partial<Omit<CreateTaskInput, 'reporterId'>>;

// 任务查询选项
export interface TaskQueryOptions {
  status?: TaskStatus;
  priority?: TaskPriority;
  type?: TaskType;
  assigneeId?: string;
  reporterId?: string;
  teamId?: string;
  projectId?: string;
  tags?: string[];
  dueDateFrom?: Date;
  dueDateTo?: Date;
  search?: string;
  sortBy?: keyof Task;
  sortOrder?: 'asc' | 'desc';
  limit?: number;
  offset?: number;
}

// 任务统计类型
export interface TaskStats {
  total: number;
  byStatus: Record<TaskStatus, number>;
  byPriority: Record<TaskPriority, number>;
  byType: Record<TaskType, number>;
  overdue: number;
  completedThisWeek: number;
  averageCompletionTime: number;
}
```

#### 2.2 任务服务实现
```typescript
// src/services/taskService.ts
import { Task, CreateTaskInput, UpdateTaskInput, TaskQueryOptions, TaskStats, TaskStatus } from '../types/task';
import { ApiResponse, PaginatedResponse } from '../types/api';

export interface TaskService {
  createTask(input: CreateTaskInput): Promise<ApiResponse<Task>>;
  getTaskById(id: string): Promise<ApiResponse<Task>>;
  updateTask(id: string, input: UpdateTaskInput): Promise<ApiResponse<Task>>;
  deleteTask(id: string): Promise<ApiResponse<void>>;
  getTasks(options: TaskQueryOptions): Promise<ApiResponse<PaginatedResponse<Task>>>;
  updateTaskStatus(id: string, status: TaskStatus): Promise<ApiResponse<Task>>;
  assignTask(id: string, assigneeId: string): Promise<ApiResponse<Task>>;
  getTaskStats(teamId?: string): Promise<ApiResponse<TaskStats>>;
  searchTasks(query: string): Promise<ApiResponse<Task[]>>;
}

export class TaskServiceImpl implements TaskService {
  private tasks: Map<string, Task> = new Map();

  async createTask(input: CreateTaskInput): Promise<ApiResponse<Task>> {
    try {
      const task: Task = {
        ...input,
        id: this.generateId(),
        createdAt: new Date(),
        updatedAt: new Date(),
        attachments: [],
        comments: []
      };

      this.tasks.set(task.id, task);

      return {
        success: true,
        data: task
      };
    } catch (error) {
      return {
        success: false,
        error: { code: 'INTERNAL_ERROR', message: 'Failed to create task' }
      };
    }
  }

  async getTaskById(id: string): Promise<ApiResponse<Task>> {
    const task = this.tasks.get(id);
    if (!task) {
      return {
        success: false,
        error: { code: 'TASK_NOT_FOUND', message: 'Task not found' }
      };
    }

    return {
      success: true,
      data: task
    };
  }

  async updateTask(id: string, input: UpdateTaskInput): Promise<ApiResponse<Task>> {
    const task = this.tasks.get(id);
    if (!task) {
      return {
        success: false,
        error: { code: 'TASK_NOT_FOUND', message: 'Task not found' }
      };
    }

    const updatedTask: Task = {
      ...task,
      ...input,
      updatedAt: new Date()
    };

    this.tasks.set(id, updatedTask);

    return {
      success: true,
      data: updatedTask
    };
  }

  async deleteTask(id: string): Promise<ApiResponse<void>> {
    if (!this.tasks.has(id)) {
      return {
        success: false,
        error: { code: 'TASK_NOT_FOUND', message: 'Task not found' }
      };
    }

    this.tasks.delete(id);

    return {
      success: true,
      data: undefined
    };
  }

  async getTasks(options: TaskQueryOptions): Promise<ApiResponse<PaginatedResponse<Task>>> {
    let tasks = Array.from(this.tasks.values());

    // 应用过滤器
    if (options.status) {
      tasks = tasks.filter(task => task.status === options.status);
    }

    if (options.priority) {
      tasks = tasks.filter(task => task.priority === options.priority);
    }

    if (options.type) {
      tasks = tasks.filter(task => task.type === options.type);
    }

    if (options.assigneeId) {
      tasks = tasks.filter(task => task.assigneeId === options.assigneeId);
    }

    if (options.reporterId) {
      tasks = tasks.filter(task => task.reporterId === options.reporterId);
    }

    if (options.teamId) {
      tasks = tasks.filter(task => task.teamId === options.teamId);
    }

    if (options.projectId) {
      tasks = tasks.filter(task => task.projectId === options.projectId);
    }

    if (options.tags && options.tags.length > 0) {
      tasks = tasks.filter(task => 
        options.tags!.some(tag => task.tags.includes(tag))
      );
    }

    if (options.dueDateFrom) {
      tasks = tasks.filter(task => 
        task.dueDate && task.dueDate >= options.dueDateFrom!
      );
    }

    if (options.dueDateTo) {
      tasks = tasks.filter(task => 
        task.dueDate && task.dueDate <= options.dueDateTo!
      );
    }

    if (options.search) {
      const searchLower = options.search.toLowerCase();
      tasks = tasks.filter(task => 
        task.title.toLowerCase().includes(searchLower) ||
        task.description.toLowerCase().includes(searchLower)
      );
    }

    // 应用排序
    if (options.sortBy) {
      tasks.sort((a, b) => {
        const aValue = a[options.sortBy!];
        const bValue = b[options.sortBy!];
        
        if (aValue < bValue) return options.sortOrder === 'desc' ? 1 : -1;
        if (aValue > bValue) return options.sortOrder === 'desc' ? -1 : 1;
        return 0;
      });
    }

    // 应用分页
    const limit = options.limit || 10;
    const offset = options.offset || 0;
    const paginatedTasks = tasks.slice(offset, offset + limit);

    return {
      success: true,
      data: {
        items: paginatedTasks,
        total: tasks.length,
        limit,
        offset,
        hasMore: offset + limit < tasks.length
      }
    };
  }

  async updateTaskStatus(id: string, status: TaskStatus): Promise<ApiResponse<Task>> {
    const task = this.tasks.get(id);
    if (!task) {
      return {
        success: false,
        error: { code: 'TASK_NOT_FOUND', message: 'Task not found' }
      };
    }

    const updatedTask: Task = {
      ...task,
      status,
      updatedAt: new Date(),
      completedAt: status === TaskStatus.DONE ? new Date() : undefined
    };

    this.tasks.set(id, updatedTask);

    return {
      success: true,
      data: updatedTask
    };
  }

  async assignTask(id: string, assigneeId: string): Promise<ApiResponse<Task>> {
    const task = this.tasks.get(id);
    if (!task) {
      return {
        success: false,
        error: { code: 'TASK_NOT_FOUND', message: 'Task not found' }
      };
    }

    const updatedTask: Task = {
      ...task,
      assigneeId,
      updatedAt: new Date()
    };

    this.tasks.set(id, updatedTask);

    return {
      success: true,
      data: updatedTask
    };
  }

  async getTaskStats(teamId?: string): Promise<ApiResponse<TaskStats>> {
    let tasks = Array.from(this.tasks.values());

    if (teamId) {
      tasks = tasks.filter(task => task.teamId === teamId);
    }

    const stats: TaskStats = {
      total: tasks.length,
      byStatus: {
        [TaskStatus.TODO]: 0,
        [TaskStatus.IN_PROGRESS]: 0,
        [TaskStatus.REVIEW]: 0,
        [TaskStatus.DONE]: 0,
        [TaskStatus.CANCELLED]: 0
      },
      byPriority: {
        [TaskPriority.LOW]: 0,
        [TaskPriority.MEDIUM]: 0,
        [TaskPriority.HIGH]: 0,
        [TaskPriority.URGENT]: 0
      },
      byType: {
        [TaskType.FEATURE]: 0,
        [TaskType.BUG]: 0,
        [TaskType.IMPROVEMENT]: 0,
        [TaskType.DOCUMENTATION]: 0,
        [TaskType.TEST]: 0
      },
      overdue: 0,
      completedThisWeek: 0,
      averageCompletionTime: 0
    };

    const now = new Date();
    const oneWeekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);

    tasks.forEach(task => {
      stats.byStatus[task.status]++;
      stats.byPriority[task.priority]++;
      stats.byType[task.type]++;

      if (task.dueDate && task.dueDate < now && task.status !== TaskStatus.DONE) {
        stats.overdue++;
      }

      if (task.completedAt && task.completedAt > oneWeekAgo) {
        stats.completedThisWeek++;
      }
    });

    return {
      success: true,
      data: stats
    };
  }

  async searchTasks(query: string): Promise<ApiResponse<Task[]>> {
    const searchLower = query.toLowerCase();
    const results = Array.from(this.tasks.values()).filter(task =>
      task.title.toLowerCase().includes(searchLower) ||
      task.description.toLowerCase().includes(searchLower) ||
      task.tags.some(tag => tag.toLowerCase().includes(searchLower))
    );

    return {
      success: true,
      data: results
    };
  }

  private generateId(): string {
    return Math.random().toString(36).substr(2, 9);
  }
}
```

### 3. 权限管理系统

#### 3.1 权限类型定义
```typescript
// src/types/permission.ts
export enum Permission {
  // 用户权限
  USER_CREATE = 'user:create',
  USER_READ = 'user:read',
  USER_UPDATE = 'user:update',
  USER_DELETE = 'user:delete',
  
  // 任务权限
  TASK_CREATE = 'task:create',
  TASK_READ = 'task:read',
  TASK_UPDATE = 'task:update',
  TASK_DELETE = 'task:delete',
  TASK_ASSIGN = 'task:assign',
  
  // 团队权限
  TEAM_CREATE = 'team:create',
  TEAM_READ = 'team:read',
  TEAM_UPDATE = 'team:update',
  TEAM_DELETE = 'team:delete',
  TEAM_MANAGE_MEMBERS = 'team:manage_members',
  
  // 项目权限
  PROJECT_CREATE = 'project:create',
  PROJECT_READ = 'project:read',
  PROJECT_UPDATE = 'project:update',
  PROJECT_DELETE = 'project:delete',
  
  // 系统权限
  SYSTEM_ADMIN = 'system:admin',
  SYSTEM_CONFIG = 'system:config',
  SYSTEM_LOGS = 'system:logs'
}

export interface Role {
  id: string;
  name: string;
  description: string;
  permissions: Permission[];
  isSystem: boolean;
  createdAt: Date;
  updatedAt: Date;
}

export interface PermissionCheck {
  resource: string;
  action: string;
  context?: Record<string, any>;
}

export interface AccessControl {
  userId: string;
  resourceId: string;
  resourceType: string;
  permissions: Permission[];
  grantedAt: Date;
  expiresAt?: Date;
}

// 权限检查结果
export type PermissionResult = {
  granted: boolean;
  reason?: string;
  requiredPermissions?: Permission[];
};

// 角色权限映射
export type RolePermissionMap = Record<string, Permission[]>;
```

#### 3.2 权限服务实现
```typescript
// src/services/permissionService.ts
import { Permission, Role, PermissionCheck, AccessControl, PermissionResult, RolePermissionMap } from '../types/permission';
import { UserRole } from '../types/user';
import { ApiResponse } from '../types/api';

export interface PermissionService {
  checkPermission(userId: string, permission: Permission, context?: any): Promise<PermissionResult>;
  checkMultiplePermissions(userId: string, permissions: Permission[], context?: any): Promise<PermissionResult>;
  hasRole(userId: string, role: UserRole): Promise<boolean>;
  getUserPermissions(userId: string): Promise<Permission[]>;
  grantPermission(userId: string, resourceId: string, resourceType: string, permissions: Permission[]): Promise<ApiResponse<AccessControl>>;
  revokePermission(userId: string, resourceId: string, resourceType: string): Promise<ApiResponse<void>>;
  createRole(name: string, description: string, permissions: Permission[]): Promise<ApiResponse<Role>>;
  updateRole(roleId: string, permissions: Permission[]): Promise<ApiResponse<Role>>;
}

export class PermissionServiceImpl implements PermissionService {
  private rolePermissions: RolePermissionMap = {
    [UserRole.ADMIN]: [
      Permission.USER_CREATE,
      Permission.USER_READ,
      Permission.USER_UPDATE,
      Permission.USER_DELETE,
      Permission.TASK_CREATE,
      Permission.TASK_READ,
      Permission.TASK_UPDATE,
      Permission.TASK_DELETE,
      Permission.TASK_ASSIGN,
      Permission.TEAM_CREATE,
      Permission.TEAM_READ,
      Permission.TEAM_UPDATE,
      Permission.TEAM_DELETE,
      Permission.TEAM_MANAGE_MEMBERS,
      Permission.PROJECT_CREATE,
      Permission.PROJECT_READ,
      Permission.PROJECT_UPDATE,
      Permission.PROJECT_DELETE,
      Permission.SYSTEM_ADMIN,
      Permission.SYSTEM_CONFIG,
      Permission.SYSTEM_LOGS
    ],
    [UserRole.MANAGER]: [
      Permission.USER_READ,
      Permission.USER_UPDATE,
      Permission.TASK_CREATE,
      Permission.TASK_READ,
      Permission.TASK_UPDATE,
      Permission.TASK_DELETE,
      Permission.TASK_ASSIGN,
      Permission.TEAM_READ,
      Permission.TEAM_UPDATE,
      Permission.TEAM_MANAGE_MEMBERS,
      Permission.PROJECT_CREATE,
      Permission.PROJECT_READ,
      Permission.PROJECT_UPDATE
    ],
    [UserRole.MEMBER]: [
      Permission.USER_READ,
      Permission.TASK_CREATE,
      Permission.TASK_READ,
      Permission.TASK_UPDATE,
      Permission.TEAM_READ,
      Permission.PROJECT_READ
    ],
    [UserRole.GUEST]: [
      Permission.USER_READ,
      Permission.TASK_READ,
      Permission.TEAM_READ,
      Permission.PROJECT_READ
    ]
  };

  private accessControls: Map<string, AccessControl[]> = new Map();

  async checkPermission(userId: string, permission: Permission, context?: any): Promise<PermissionResult> {
    try {
      // 获取用户角色权限
      const userPermissions = await this.getUserPermissions(userId);
      
      if (userPermissions.includes(permission)) {
        return { granted: true };
      }

      // 检查资源特定权限
      const resourcePermissions = await this.getResourcePermissions(userId, context);
      if (resourcePermissions.includes(permission)) {
        return { granted: true };
      }

      return {
        granted: false,
        reason: 'Insufficient permissions',
        requiredPermissions: [permission]
      };
    } catch (error) {
      return {
        granted: false,
        reason: 'Permission check failed'
      };
    }
  }

  async checkMultiplePermissions(userId: string, permissions: Permission[], context?: any): Promise<PermissionResult> {
    const results = await Promise.all(
      permissions.map(permission => this.checkPermission(userId, permission, context))
    );

    const deniedPermissions = permissions.filter((_, index) => !results[index].granted);

    if (deniedPermissions.length === 0) {
      return { granted: true };
    }

    return {
      granted: false,
      reason: 'Some permissions are missing',
      requiredPermissions: deniedPermissions
    };
  }

  async hasRole(userId: string, role: UserRole): Promise<boolean> {
    // 这里应该从数据库获取用户角色
    // 为了演示，我们假设所有用户都有 MEMBER 角色
    return role === UserRole.MEMBER;
  }

  async getUserPermissions(userId: string): Promise<Permission[]> {
    // 这里应该从数据库获取用户角色和权限
    // 为了演示，我们返回 MEMBER 角色的权限
    return this.rolePermissions[UserRole.MEMBER] || [];
  }

  async getResourcePermissions(userId: string, context?: any): Promise<Permission[]> {
    if (!context?.resourceId || !context?.resourceType) {
      return [];
    }

    const userAccessControls = this.accessControls.get(userId) || [];
    return userAccessControls
      .filter(ac => ac.resourceId === context.resourceId && ac.resourceType === context.resourceType)
      .flatMap(ac => ac.permissions);
  }

  async grantPermission(userId: string, resourceId: string, resourceType: string, permissions: Permission[]): Promise<ApiResponse<AccessControl>> {
    try {
      const accessControl: AccessControl = {
        userId,
        resourceId,
        resourceType,
        permissions,
        grantedAt: new Date()
      };

      const userAccessControls = this.accessControls.get(userId) || [];
      userAccessControls.push(accessControl);
      this.accessControls.set(userId, userAccessControls);

      return {
        success: true,
        data: accessControl
      };
    } catch (error) {
      return {
        success: false,
        error: { code: 'INTERNAL_ERROR', message: 'Failed to grant permission' }
      };
    }
  }

  async revokePermission(userId: string, resourceId: string, resourceType: string): Promise<ApiResponse<void>> {
    try {
      const userAccessControls = this.accessControls.get(userId) || [];
      const filteredControls = userAccessControls.filter(
        ac => !(ac.resourceId === resourceId && ac.resourceType === resourceType)
      );
      this.accessControls.set(userId, filteredControls);

      return {
        success: true,
        data: undefined
      };
    } catch (error) {
      return {
        success: false,
        error: { code: 'INTERNAL_ERROR', message: 'Failed to revoke permission' }
      };
    }
  }

  async createRole(name: string, description: string, permissions: Permission[]): Promise<ApiResponse<Role>> {
    try {
      const role: Role = {
        id: this.generateId(),
        name,
        description,
        permissions,
        isSystem: false,
        createdAt: new Date(),
        updatedAt: new Date()
      };

      return {
        success: true,
        data: role
      };
    } catch (error) {
      return {
        success: false,
        error: { code: 'INTERNAL_ERROR', message: 'Failed to create role' }
      };
    }
  }

  async updateRole(roleId: string, permissions: Permission[]): Promise<ApiResponse<Role>> {
    try {
      // 这里应该从数据库更新角色
      // 为了演示，我们返回一个模拟的角色
      const role: Role = {
        id: roleId,
        name: 'Updated Role',
        description: 'Updated role description',
        permissions,
        isSystem: false,
        createdAt: new Date(),
        updatedAt: new Date()
      };

      return {
        success: true,
        data: role
      };
    } catch (error) {
      return {
        success: false,
        error: { code: 'INTERNAL_ERROR', message: 'Failed to update role' }
      };
    }
  }

  private generateId(): string {
    return Math.random().toString(36).substr(2, 9);
  }
}
```

## 实践练习

### 练习1：类型安全的API设计
```typescript
// 任务：设计类型安全的API响应系统
// 要求：
// 1. 支持泛型响应类型
// 2. 支持分页响应
// 3. 支持错误处理
// 4. 支持数据转换

// 你的实现
```

### 练习2：高级类型编程
```typescript
// 任务：创建类型安全的查询构建器
// 要求：
// 1. 支持链式调用
// 2. 支持类型推断
// 3. 支持条件查询
// 4. 支持排序和分页

// 你的实现
```

### 练习3：装饰器应用
```typescript
// 任务：创建权限检查装饰器
// 要求：
// 1. 支持方法级权限检查
// 2. 支持参数级权限检查
// 3. 支持自定义权限逻辑
// 4. 支持错误处理

// 你的实现
```

## 学习检查点

- [ ] 完成用户管理系统类型定义
- [ ] 实现任务管理系统服务
- [ ] 创建权限管理系统
- [ ] 设计类型安全的API
- [ ] 实现高级类型编程技巧
- [ ] 通过所有类型测试

## 下一步学习

完成本部分学习后，请继续学习 [4.2 代码审查和优化](./4.2-code-review.md)。



