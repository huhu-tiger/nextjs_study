# 3.2 现代JavaScript特性

## 学习目标
- 掌握ES2023+新特性
- 理解顶层await和模块加载
- 熟练使用数组和对象的新方法
- 了解正则表达式增强
- 掌握错误处理改进

## 学习内容

### 1. ES2023+ 新特性

#### 1.1 顶层await
```typescript
// 顶层await - 在模块顶层使用await
// 不需要包装在async函数中

// 动态导入模块
const { default: config } = await import('./config.js');
console.log(config);

// 异步初始化
const database = await initializeDatabase();
const cache = await initializeCache();

// 条件导入
const moduleName = process.env.NODE_ENV === 'production' 
  ? './prod-module.js' 
  : './dev-module.js';
const { default: Module } = await import(moduleName);

// 错误处理
try {
  const { default: config } = await import('./config.js');
  console.log('Config loaded:', config);
} catch (error) {
  console.error('Failed to load config:', error);
}
```

#### 1.2 模块加载增强
```typescript
// 动态导入返回Promise
const loadModule = async (moduleName: string) => {
  try {
    const module = await import(moduleName);
    return module;
  } catch (error) {
    console.error(`Failed to load module ${moduleName}:`, error);
    return null;
  }
};

// 条件模块加载
const loadFeature = async (featureName: string) => {
  const featureMap = {
    'auth': () => import('./features/auth.js'),
    'dashboard': () => import('./features/dashboard.js'),
    'settings': () => import('./features/settings.js')
  };
  
  const loader = featureMap[featureName as keyof typeof featureMap];
  if (loader) {
    return await loader();
  }
  throw new Error(`Unknown feature: ${featureName}`);
};

// 并行模块加载
const loadMultipleModules = async (moduleNames: string[]) => {
  const modules = await Promise.all(
    moduleNames.map(name => import(name))
  );
  return modules;
};
```

#### 1.3 数组和对象新方法
```typescript
// 数组新方法
const numbers = [1, 2, 3, 4, 5];

// Array.prototype.findLast()
const lastEven = numbers.findLast(n => n % 2 === 0);
console.log(lastEven); // 4

// Array.prototype.findLastIndex()
const lastEvenIndex = numbers.findLastIndex(n => n % 2 === 0);
console.log(lastEvenIndex); // 3

// Array.prototype.toReversed()
const reversed = numbers.toReversed();
console.log(reversed); // [5, 4, 3, 2, 1]
console.log(numbers); // [1, 2, 3, 4, 5] (原数组不变)

// Array.prototype.toSorted()
const unsorted = [3, 1, 4, 1, 5];
const sorted = unsorted.toSorted();
console.log(sorted); // [1, 1, 3, 4, 5]
console.log(unsorted); // [3, 1, 4, 1, 5] (原数组不变)

// Array.prototype.toSpliced()
const spliced = numbers.toSpliced(1, 2, 10, 11);
console.log(spliced); // [1, 10, 11, 4, 5]
console.log(numbers); // [1, 2, 3, 4, 5] (原数组不变)

// Array.prototype.with()
const withNew = numbers.with(2, 100);
console.log(withNew); // [1, 2, 100, 4, 5]
console.log(numbers); // [1, 2, 3, 4, 5] (原数组不变)
```

#### 1.4 对象新方法
```typescript
// Object.hasOwn()
const obj = { a: 1, b: 2, c: 3 };

// 替代 Object.prototype.hasOwnProperty.call()
console.log(Object.hasOwn(obj, 'a')); // true
console.log(Object.hasOwn(obj, 'd')); // false

// 更安全的方式
const hasProperty = (obj: any, prop: string) => {
  return Object.hasOwn(obj, prop);
};

// 对象属性检查
const checkObjectProperties = (obj: any, properties: string[]) => {
  return properties.every(prop => Object.hasOwn(obj, prop));
};

// 使用示例
const user = { name: 'John', email: 'john@example.com' };
const requiredProps = ['name', 'email', 'age'];
const isValid = checkObjectProperties(user, requiredProps);
console.log(isValid); // false (缺少age属性)
```

### 2. 正则表达式增强

#### 2.1 正则表达式新特性
```typescript
// 正则表达式匹配索引
const text = "Hello World! Hello TypeScript!";
const regex = /Hello/g;
const matches = [...text.matchAll(regex)];

// 获取匹配的索引
matches.forEach(match => {
  console.log(`Match: "${match[0]}" at index ${match.index}`);
});

// 命名捕获组
const emailRegex = /(?<username>[a-zA-Z0-9._-]+)@(?<domain>[a-zA-Z0-9.-]+)\.(?<tld>[a-zA-Z]{2,})/;
const email = "user@example.com";
const match = email.match(emailRegex);

if (match) {
  console.log('Username:', match.groups?.username);
  console.log('Domain:', match.groups?.domain);
  console.log('TLD:', match.groups?.tld);
}

// 正则表达式标志
const globalRegex = /hello/gi;
const stickyRegex = /hello/y;
const unicodeRegex = /hello/u;
```

#### 2.2 正则表达式工具函数
```typescript
// 正则表达式工具类
class RegexUtils {
  // 邮箱验证
  static validateEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }
  
  // 手机号验证
  static validatePhone(phone: string): boolean {
    const phoneRegex = /^1[3-9]\d{9}$/;
    return phoneRegex.test(phone);
  }
  
  // 密码强度验证
  static validatePassword(password: string): {
    isValid: boolean;
    strength: 'weak' | 'medium' | 'strong';
    message: string;
  } {
    const minLength = 8;
    const hasUpperCase = /[A-Z]/.test(password);
    const hasLowerCase = /[a-z]/.test(password);
    const hasNumbers = /\d/.test(password);
    const hasSpecialChar = /[!@#$%^&*(),.?":{}|<>]/.test(password);
    
    if (password.length < minLength) {
      return {
        isValid: false,
        strength: 'weak',
        message: `Password must be at least ${minLength} characters long`
      };
    }
    
    const score = [hasUpperCase, hasLowerCase, hasNumbers, hasSpecialChar]
      .filter(Boolean).length;
    
    if (score < 2) {
      return {
        isValid: false,
        strength: 'weak',
        message: 'Password must contain at least 2 of: uppercase, lowercase, numbers, special characters'
      };
    }
    
    if (score < 3) {
      return {
        isValid: true,
        strength: 'medium',
        message: 'Password strength: medium'
      };
    }
    
    return {
      isValid: true,
      strength: 'strong',
      message: 'Password strength: strong'
    };
  }
}
```

### 3. 错误处理改进

#### 3.1 现代错误处理
```typescript
// 错误类型定义
class ValidationError extends Error {
  constructor(
    message: string,
    public field: string,
    public value: any
  ) {
    super(message);
    this.name = 'ValidationError';
  }
}

class NetworkError extends Error {
  constructor(
    message: string,
    public statusCode: number,
    public url: string
  ) {
    super(message);
    this.name = 'NetworkError';
  }
}

// 错误处理工具
class ErrorHandler {
  static handle(error: unknown): string {
    if (error instanceof ValidationError) {
      return `Validation error in ${error.field}: ${error.message}`;
    }
    
    if (error instanceof NetworkError) {
      return `Network error (${error.statusCode}): ${error.message}`;
    }
    
    if (error instanceof Error) {
      return `Error: ${error.message}`;
    }
    
    return 'Unknown error occurred';
  }
  
  static async withRetry<T>(
    fn: () => Promise<T>,
    maxRetries: number = 3,
    delay: number = 1000
  ): Promise<T> {
    let lastError: Error;
    
    for (let i = 0; i < maxRetries; i++) {
      try {
        return await fn();
      } catch (error) {
        lastError = error as Error;
        
        if (i < maxRetries - 1) {
          await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, i)));
        }
      }
    }
    
    throw lastError!;
  }
}
```

#### 3.2 异步错误处理
```typescript
// 异步错误处理模式
const asyncOperation = async (): Promise<string> => {
  try {
    const result = await fetch('/api/data');
    if (!result.ok) {
      throw new NetworkError(`HTTP ${result.status}`, result.status, '/api/data');
    }
    return await result.text();
  } catch (error) {
    if (error instanceof NetworkError) {
      throw error;
    }
    throw new Error(`Unexpected error: ${error}`);
  }
};

// 错误边界组件
class ErrorBoundary {
  private static error: Error | null = null;
  
  static catch(error: Error): void {
    this.error = error;
  }
  
  static getError(): Error | null {
    return this.error;
  }
  
  static clearError(): void {
    this.error = null;
  }
}

// 全局错误处理
window.addEventListener('error', (event) => {
  console.error('Global error:', event.error);
  ErrorBoundary.catch(event.error);
});

window.addEventListener('unhandledrejection', (event) => {
  console.error('Unhandled promise rejection:', event.reason);
  ErrorBoundary.catch(new Error(event.reason));
});
```

### 4. 现代JavaScript模式

#### 4.1 可选链和空值合并
```typescript
// 可选链操作符
interface User {
  name: string;
  address?: {
    street?: string;
    city?: string;
    country?: string;
  };
  contacts?: {
    email?: string;
    phone?: string;
  };
}

const user: User = {
  name: 'John',
  address: {
    street: '123 Main St',
    city: 'New York'
  }
};

// 安全访问嵌套属性
const street = user.address?.street;
const country = user.address?.country;
const email = user.contacts?.email;

// 空值合并操作符
const defaultCountry = user.address?.country ?? 'Unknown';
const defaultEmail = user.contacts?.email ?? 'No email provided';

// 组合使用
const displayAddress = user.address?.street && user.address?.city 
  ? `${user.address.street}, ${user.address.city}` 
  : 'Address not available';
```

#### 4.2 解构和展开
```typescript
// 对象解构
const { name, address, contacts } = user;
const { street, city, country } = address || {};

// 数组解构
const numbers = [1, 2, 3, 4, 5];
const [first, second, ...rest] = numbers;

// 解构重命名
const { name: userName, address: userAddress } = user;

// 解构默认值
const { name: userName = 'Anonymous', age = 0 } = user;

// 展开操作符
const userWithId = { ...user, id: 1 };
const extendedUser = { ...user, ...userWithId, lastLogin: new Date() };

// 数组展开
const allNumbers = [...numbers, 6, 7, 8];
const mergedArrays = [...numbers, ...allNumbers];
```

#### 4.3 现代循环和迭代
```typescript
// for...of 循环
const fruits = ['apple', 'banana', 'orange'];
for (const fruit of fruits) {
  console.log(fruit);
}

// 对象迭代
const userData = {
  name: 'John',
  age: 30,
  email: 'john@example.com'
};

for (const [key, value] of Object.entries(userData)) {
  console.log(`${key}: ${value}`);
}

// 异步迭代
async function* asyncGenerator() {
  yield 1;
  yield 2;
  yield 3;
}

for await (const value of asyncGenerator()) {
  console.log(value);
}

// 迭代器协议
class NumberRange {
  constructor(private start: number, private end: number) {}
  
  *[Symbol.iterator]() {
    for (let i = this.start; i <= this.end; i++) {
      yield i;
    }
  }
}

const range = new NumberRange(1, 5);
for (const num of range) {
  console.log(num);
}
```

## 实践练习

### 练习1：现代数组操作
```typescript
// 任务：使用现代数组方法处理数据
const products = [
  { id: 1, name: 'Laptop', price: 999, category: 'Electronics' },
  { id: 2, name: 'Mouse', price: 29, category: 'Electronics' },
  { id: 3, name: 'Book', price: 15, category: 'Books' },
  { id: 4, name: 'Pen', price: 2, category: 'Office' },
  { id: 5, name: 'Phone', price: 699, category: 'Electronics' }
];

// 1. 使用findLast找到最后一个电子产品
const lastElectronics = /* 你的实现 */;

// 2. 使用toSorted按价格排序（不改变原数组）
const sortedByPrice = /* 你的实现 */;

// 3. 使用toSpliced移除第一个元素并添加新元素
const modifiedProducts = /* 你的实现 */;

// 4. 使用with更新特定索引的元素
const updatedProduct = /* 你的实现 */;
```

### 练习2：正则表达式应用
```typescript
// 任务：创建正则表达式工具类
class RegexUtils {
  // 1. 验证URL
  static validateUrl(url: string): boolean {
    // 你的实现
  }
  
  // 2. 提取邮箱地址
  static extractEmails(text: string): string[] {
    // 你的实现
  }
  
  // 3. 验证密码强度
  static validatePasswordStrength(password: string): {
    isValid: boolean;
    score: number;
    feedback: string[];
  } {
    // 你的实现
  }
  
  // 4. 格式化手机号
  static formatPhoneNumber(phone: string): string {
    // 你的实现
  }
}
```

### 练习3：错误处理系统
```typescript
// 任务：创建完整的错误处理系统
class ErrorSystem {
  // 1. 定义错误类型
  static createError(type: string, message: string, context?: any): Error {
    // 你的实现
  }
  
  // 2. 错误重试机制
  static async withRetry<T>(
    operation: () => Promise<T>,
    options: {
      maxRetries: number;
      delay: number;
      backoff: 'linear' | 'exponential';
    }
  ): Promise<T> {
    // 你的实现
  }
  
  // 3. 错误日志记录
  static logError(error: Error, context?: any): void {
    // 你的实现
  }
  
  // 4. 错误恢复策略
  static async withFallback<T>(
    primary: () => Promise<T>,
    fallback: () => Promise<T>
  ): Promise<T> {
    // 你的实现
  }
}
```

## 学习检查点

- [ ] 掌握ES2023+新特性
- [ ] 理解顶层await和模块加载
- [ ] 熟练使用数组和对象的新方法
- [ ] 了解正则表达式增强
- [ ] 掌握错误处理改进

## 下一步学习

完成本部分学习后，请继续学习 [3.3 实践练习](./3.3-practice-exercises.md)。
