# 1.2 高级类型编程

## 学习目标
- 掌握泛型基础和高级约束
- 理解条件类型和映射类型
- 熟练使用模板字面量类型
- 掌握工具类型的深入应用
- 了解类型级编程技巧

## 学习内容

### 1. 泛型基础和高级约束

#### 1.1 基础泛型
```typescript
// 基础泛型函数
// <T> 表示泛型参数，T 可以是任何类型
// 函数接收 T 类型的参数，返回 T 类型的结果
function identity<T>(arg: T): T {
  return arg;
}

// 使用示例：
// const result1 = identity<string>("hello"); // result1 类型为 string
// const result2 = identity<number>(42);      // result2 类型为 number
// const result3 = identity("hello");         // TypeScript 自动推断为 string

// 泛型接口
// T 是泛型参数，可以在接口内部使用
// 这个接口可以处理任何类型的数据
interface GenericResponse<T> {
  data: T;        // 数据类型由泛型参数 T 决定
  status: number; // 状态码始终是 number
  message: string; // 消息始终是 string
}

// 使用示例：
// const userResponse: GenericResponse<User> = { data: user, status: 200, message: "OK" };
// const stringResponse: GenericResponse<string> = { data: "hello", status: 200, message: "OK" };

// 泛型类
// T 是泛型参数，整个类都基于这个类型工作
// 这样可以创建类型安全的存储库
class GenericRepository<T> {
  private items: T[] = []; // 存储 T 类型的数组
  
  // 添加 T 类型的项目
  add(item: T): void {
    this.items.push(item);
  }
  
  // 根据索引获取 T 类型的项目，可能为 undefined
  getById(id: number): T | undefined {
    return this.items[id];
  }
}

// 使用示例：
// const userRepo = new GenericRepository<User>();
// userRepo.add({ id: 1, name: "John" }); // 只能添加 User 类型
// const user = userRepo.getById(0);       // 返回 User | undefined
```

#### 1.2 泛型约束
```typescript
// 基础约束
// 定义一个接口，要求对象必须有 length 属性
interface HasLength {
  length: number;
}

// T extends HasLength 表示 T 必须满足 HasLength 接口
// 这样我们就可以安全地访问 arg.length 属性
function logLength<T extends HasLength>(arg: T): T {
  console.log(arg.length); // 安全：T 保证有 length 属性
  return arg;
}

// 使用示例：
// logLength("hello");     // ✅ string 有 length 属性
// logLength([1, 2, 3]);   // ✅ array 有 length 属性
// logLength(42);          // ❌ number 没有 length 属性

// 多重约束
// 定义两个独立的接口
interface Serializable {
  serialize(): string; // 对象必须能序列化为字符串
}

interface Deserializable {
  deserialize(data: string): void; // 对象必须能从字符串反序列化
}

// T 必须同时满足 Serializable 和 Deserializable 接口
// 使用 & 操作符表示交集（同时满足两个接口）
function processData<T extends Serializable & Deserializable>(item: T): T {
  const serialized = item.serialize();    // 安全：T 保证有 serialize 方法
  item.deserialize(serialized);           // 安全：T 保证有 deserialize 方法
  return item;
}
class SerializableDeserializable implements Serializable, Deserializable {
    private items: T[]=string[] = []; // 存储 T 类型的数组
    serialize(): string {
      return this.items[0];
    }

    deserialize(data: string): void {
      this.items.push(data);
    }
    constructor(items: T[]){
      this.items=items;
    }
}
processData(new SerializableDeserialiszable(["a", "b"]))


// 使用 keyof 约束
// K extends keyof T 表示 K 必须是 T 对象的键名之一
// 这样可以确保 key 参数是 obj 的有效属性名
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key]; // 安全：key 保证是 obj 的有效属性
}

// 使用示例：
// const user = { name: "John", age: 30 };
// const name = getProperty(user, "name"); // ✅ 返回 string
// const age = getProperty(user, "age");   // ✅ 返回 number
// const invalid = getProperty(user, "email"); // ❌ "email" 不是 user 的属性
```

#### 1.3 泛型默认值
```typescript
// 泛型默认值
// T = any 表示如果没有指定类型，默认使用 any
// 这样可以让接口更灵活，同时保持类型安全
interface ApiResponse<T = any> {
  data: T;        // 数据类型，默认为 any
  status: number; // 状态码始终是 number
}

// 使用默认值
// 没有指定泛型参数，T 默认为 any
const response: ApiResponse = { data: "hello", status: 200 };
// 等价于：const response: ApiResponse<any> = { data: "hello", status: 200 };

// 指定具体类型
const userResponse: ApiResponse<User> = { data: user, status: 200 };

// 条件默认值
// 这是一个条件类型，根据 T 的类型决定结果
// 如果 T 是 string 类型，返回 `/api/${T}` 格式的字符串
// 否则返回 never（表示不可能的类型）
type ApiEndpoint<T = string> = T extends string ? `/api/${T}` : never;

// 使用示例：
// type UserEndpoint = ApiEndpoint<"users">; // 结果: "/api/users"
// type PostEndpoint = ApiEndpoint<"posts">; // 结果: "/api/posts"
// type InvalidEndpoint = ApiEndpoint<123>;  // 结果: never（因为 123 不是 string）
```

### 2. 条件类型 (Conditional Types)

#### 2.1 基础条件类型
```typescript
// 基础条件类型语法
// 条件类型使用三元运算符：T extends U ? X : Y
// 如果 T 可以赋值给 U，则返回 X 类型，否则返回 Y 类型
type IsString<T> = T extends string ? true : false;

// 使用示例：
// type Test1 = IsString<string>;  // 结果: true
// type Test2 = IsString<number>;  // 结果: false
// type Test3 = IsString<"hello">; // 结果: true（字面量类型是 string 的子类型）

// 实际应用
// 根据 T 的类型决定返回不同的对象结构
// 如果 T 是 string，返回 { message: T }
// 如果 T 不是 string，返回 { data: T }
type ApiResponse<T> = T extends string 
  ? { message: T } 
  : { data: T };

// 使用示例：
// type StringResponse = ApiResponse<string>;  // 结果: { message: string }
// type NumberResponse = ApiResponse<number>;  // 结果: { data: number }
// type UserResponse = ApiResponse<User>;      // 结果: { data: User }

// 嵌套条件类型
// 过滤掉 null 和 undefined 类型
// 如果 T 是 null 或 undefined，返回 never（表示不可能的类型）
// 否则返回 T 本身
type NonNullable<T> = T extends null | undefined ? never : T;

// 使用示例：
// type Test1 = NonNullable<string>;        // 结果: string
// type Test2 = NonNullable<string | null>; // 结果: string
// type Test3 = NonNullable<null>;          // 结果: never
```

#### 2.2 条件类型中的推断
```typescript
// 使用 infer 关键字
// infer 允许我们在条件类型中推断类型
// 这里推断函数的返回类型 R
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;

// 使用示例：
// type Func = () => string;
// type Result = ReturnType<Func>; // 结果: string
// type AsyncFunc = () => Promise<number>;
// type AsyncResult = ReturnType<AsyncFunc>; // 结果: Promise<number>

// 提取数组元素类型
// 如果 T 是数组类型，推断出数组元素的类型 U
// 否则返回 never
type ArrayElement<T> = T extends (infer U)[] ? U : never;

// 使用示例：
// type StringArray = string[];
// type Element = ArrayElement<StringArray>; // 结果: string
// type NumberArray = number[];
// type NumberElement = ArrayElement<NumberArray>; // 结果: number

// 提取函数参数类型
// 如果 T 是函数类型，推断出参数类型 P（元组类型）
// 否则返回 never
type Parameters<T> = T extends (...args: infer P) => any ? P : never;

// 使用示例：
// type Func = (a: string, b: number) => void;
// type Params = Parameters<Func>; // 结果: [string, number]
// type AsyncFunc = (id: number) => Promise<User>;
// type AsyncParams = Parameters<AsyncFunc>; // 结果: [number]

// 提取 Promise 类型
// 如果 T 是 Promise 类型，提取 Promise 内部的类型 U
// 否则返回 T 本身
type Awaited<T> = T extends Promise<infer U> ? U : T;

// 使用示例：
// type PromiseString = Promise<string>;
// type Unwrapped = Awaited<PromiseString>; // 结果: string
// type NotPromise = number;
// type Unwrapped2 = Awaited<NotPromise>; // 结果: number
```

#### 2.3 条件类型工具
```typescript
// 检查类型是否为函数
// 如果 T 是函数类型，返回 true，否则返回 false
type IsFunction<T> = T extends (...args: any[]) => any ? true : false;

// 使用示例：
// type Test1 = IsFunction<() => void>;     // 结果: true
// type Test2 = IsFunction<(x: number) => string>; // 结果: true
// type Test3 = IsFunction<string>;         // 结果: false

// 检查类型是否为数组
// 如果 T 是数组类型，返回 true，否则返回 false
type IsArray<T> = T extends any[] ? true : false;

// 使用示例：
// type Test1 = IsArray<string[]>;          // 结果: true
// type Test2 = IsArray<number[]>;          // 结果: true
// type Test3 = IsArray<string>;            // 结果: false

// 检查类型是否为对象（排除数组）
// 如果 T 是 object 类型但不是数组，返回 true
// 否则返回 false
type IsObject<T> = T extends object ? T extends any[] ? false : true : false;

// 使用示例：
// type Test1 = IsObject<{ name: string }>; // 结果: true
// type Test2 = IsObject<string[]>;         // 结果: false（数组被排除）
// type Test3 = IsObject<string>;           // 结果: false

// 递归条件类型
// 将对象的所有属性（包括嵌套属性）都设为只读
// 这是一个递归类型，会深入处理嵌套对象
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];
};

// 使用示例：
// interface User {
//   name: string;
//   address: {
//     street: string;
//     city: string;
//   };
// }
// type ReadonlyUser = DeepReadonly<User>;
// 结果: {
//   readonly name: string;
//   readonly address: {
//     readonly street: string;
//     readonly city: string;
//   };
// }
```

### 3. 映射类型 (Mapped Types)

#### 3.1 基础映射类型
```typescript
// 基础映射类型
// 将对象的所有属性变为可选
// [P in keyof T] 遍历 T 的所有键
// ? 使属性变为可选
type Partial<T> = {
  [P in keyof T]?: T[P];
};

// 使用示例：
// interface User { name: string; age: number; }
// type PartialUser = Partial<User>;
// 结果: { name?: string; age?: number; }

// 将对象的所有属性变为必需
// -? 移除可选标记，使属性变为必需
type Required<T> = {
  [P in keyof T]-?: T[P];
};

// 使用示例：
// interface User { name?: string; age?: number; }
// type RequiredUser = Required<User>;
// 结果: { name: string; age: number; }

// 将对象的所有属性变为只读
// readonly 使属性变为只读
type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};

// 使用示例：
// interface User { name: string; age: number; }
// type ReadonlyUser = Readonly<User>;
// 结果: { readonly name: string; readonly age: number; }

// 自定义映射类型
// 将对象的所有属性类型都改为 string
type Stringify<T> = {
  [K in keyof T]: string;
};

// 使用示例：
// interface User { name: string; age: number; }
// type StringifiedUser = Stringify<User>;
// 结果: { name: string; age: string; }
```

#### 3.2 高级映射类型
```typescript
// 条件映射
// 只选择类型为 U 的属性
// as T[K] extends U ? K : never 是键重映射，只保留符合条件的键
type PickByType<T, U> = {
  [K in keyof T as T[K] extends U ? K : never]: T[K];
};

// 使用示例：
// interface User { name: string; age: number; email: string; }
// type StringProps = PickByType<User, string>;
// 结果: { name: string; email: string; }（只包含 string 类型的属性）

// 重映射键名
// 为每个属性创建对应的 getter 方法
// `get${Capitalize<string & K>}` 是模板字面量类型
// 将属性名首字母大写并加上 "get" 前缀
type Getters<T> = {
  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];
};

// 使用示例：
// interface User { name: string; age: number; }
// type UserGetters = Getters<User>;
// 结果: { getName: () => string; getAge: () => number; }

// 过滤特定键
// 排除指定的键，保留其他键
// as P extends K ? never : P 是键重映射，排除 K 中的键
type Omit<T, K extends keyof T> = {
  [P in keyof T as P extends K ? never : P]: T[P];
};

// 使用示例：
// interface User { id: number; name: string; age: number; }
// type UserWithoutId = Omit<User, 'id'>;
// 结果: { name: string; age: number; }
```

### 4. 模板字面量类型 (Template Literal Types)

#### 4.1 基础模板字面量类型
```typescript
// 基础模板字面量
// 使用反引号和 ${} 语法创建字符串模板类型
type Greeting = `Hello, ${string}!`;
// 匹配任何以 "Hello, " 开头，以 "!" 结尾的字符串

type EventName = `on${string}`;
// 匹配任何以 "on" 开头的字符串

// 使用示例：
// const greet1: Greeting = "Hello, World!";     // ✅
// const greet2: Greeting = "Hello, TypeScript!"; // ✅
// const event1: EventName = "onClick";           // ✅
// const event2: EventName = "onMouseOver";       // ✅

// 使用联合类型
// 定义颜色联合类型
type Color = "red" | "green" | "blue";
// 为每个颜色创建对应的事件名
type ColorEvent = `on${Capitalize<Color>}Click`;

// 使用示例：
// type RedClick = `on${Capitalize<"red">}Click`; // 结果: "onRedClick"
// type GreenClick = `on${Capitalize<"green">}Click`; // 结果: "onGreenClick"
// type BlueClick = `on${Capitalize<"blue">}Click`; // 结果: "onBlueClick"

// 嵌套模板字面量
// 创建 API 端点类型
type ApiEndpoint<T extends string> = `/api/${T}`;
// 定义 HTTP 方法
type HttpMethod = "GET" | "POST" | "PUT" | "DELETE";
// 组合 HTTP 方法和 API 端点
type FullEndpoint<T extends string> = `${HttpMethod} ${ApiEndpoint<T>}`;

// 使用示例：
// type UserEndpoint = ApiEndpoint<"users">; // 结果: "/api/users"
// type GetUsers = FullEndpoint<"users">;    // 结果: "GET /api/users"
// type PostUsers = FullEndpoint<"users">;   // 结果: "POST /api/users"
```

#### 4.2 高级模板字面量类型
```typescript
// 字符串操作工具类型
// 将字符串首字母大写
// 使用 infer 推断第一个字符 F 和剩余部分 R
type Capitalize<S extends string> = S extends `${infer F}${infer R}` 
  ? `${Uppercase<F>}${R}` 
  : S;

// 使用示例：
// type Test1 = Capitalize<"hello">; // 结果: "Hello"
// type Test2 = Capitalize<"world">; // 结果: "World"

// 将字符串首字母小写
// 使用 infer 推断第一个字符 F 和剩余部分 R
type Uncapitalize<S extends string> = S extends `${infer F}${infer R}` 
  ? `${Lowercase<F>}${R}` 
  : S;

// 使用示例：
// type Test1 = Uncapitalize<"Hello">; // 结果: "hello"
// type Test2 = Uncapitalize<"World">; // 结果: "world"

// 路径操作
// 连接两个路径，用点号分隔
// 处理空字符串和数字的情况
type Join<K, P> = K extends string | number
  ? P extends string | number
    ? K extends ""
      ? P                    // 如果 K 为空，直接返回 P
      : P extends ""
      ? K                    // 如果 P 为空，直接返回 K
      : `${K}.${P}`          // 否则用点号连接
    : never
  : never;

// 使用示例：
// type Path1 = Join<"user", "name">;     // 结果: "user.name"
// type Path2 = Join<"", "name">;         // 结果: "name"
// type Path3 = Join<"user", "">;         // 结果: "user"

// 提取对象的所有路径
// 递归地提取嵌套对象的所有属性路径
type Paths<T> = T extends object
  ? {
      [K in keyof T]-?: K extends string | number
        ? `${K}` | Join<K, Paths<T[K]>>  // 当前键 + 嵌套路径
        : never;
    }[keyof T]
  : "";

// 使用示例：
// interface User {
//   name: string;
//   address: {
//     street: string;
//     city: string;
//   };
// }
// type UserPaths = Paths<User>;
// 结果: "name" | "address" | "address.street" | "address.city"
```

### 5. 工具类型深入应用

#### 5.1 内置工具类型
```typescript
// Partial 和 Required
interface User {
  id: number;
  name: string;
  email: string;
  age?: number; // 可选属性
}

// Partial: 将所有属性变为可选
type PartialUser = Partial<User>;
// 结果: { id?: number; name?: string; email?: string; age?: number; }

// Required: 将所有属性变为必需
type RequiredUser = Required<User>;
// 结果: { id: number; name: string; email: string; age: number; }

// Pick 和 Omit
// Pick: 选择指定的属性
type UserName = Pick<User, "name">;
// 结果: { name: string; }

// Omit: 排除指定的属性
type UserWithoutId = Omit<User, "id">;
// 结果: { name: string; email: string; age?: number; }

// Record
// 创建键值对类型，键为 K，值为 V
type UserRoles = Record<string, string[]>;
// 结果: { [key: string]: string[]; }

// 使用示例：
// const roles: UserRoles = {
//   admin: ["read", "write", "delete"],
//   user: ["read"]
// };

// Exclude 和 Extract
type AllowedTypes = string | number | boolean;

// Extract: 提取指定类型
type StringOnly = Extract<AllowedTypes, string>;
// 结果: string

// Exclude: 排除指定类型
type NonString = Exclude<AllowedTypes, string>;
// 结果: number | boolean
```

#### 5.2 自定义工具类型
```typescript
// 深度可选
// 递归地将对象的所有属性（包括嵌套属性）都变为可选
type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

// 使用示例：
// interface User {
//   name: string;
//   address: {
//     street: string;
//     city: string;
//   };
// }
// type PartialUser = DeepPartial<User>;
// 结果: {
//   name?: string;
//   address?: {
//     street?: string;
//     city?: string;
//   };
// }

// 深度只读
// 递归地将对象的所有属性（包括嵌套属性）都设为只读
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];
};

// 使用示例：
// interface User {
//   name: string;
//   address: {
//     street: string;
//     city: string;
//   };
// }
// type ReadonlyUser = DeepReadonly<User>;
// 结果: {
//   readonly name: string;
//   readonly address: {
//     readonly street: string;
//     readonly city: string;
//   };
// }

// 提取函数类型
// 获取对象中所有函数属性的名称
type FunctionPropertyNames<T> = {
  [K in keyof T]: T[K] extends Function ? K : never;
}[keyof T];

// 使用示例：
// interface User {
//   name: string;
//   getName: () => string;
//   setName: (name: string) => void;
//   age: number;
// }
// type FuncNames = FunctionPropertyNames<User>;
// 结果: "getName" | "setName"

// 提取非函数类型
// 获取对象中所有非函数属性的名称
type NonFunctionPropertyNames<T> = {
  [K in keyof T]: T[K] extends Function ? never : K;
}[keyof T];

// 使用示例：
// interface User {
//   name: string;
//   getName: () => string;
//   setName: (name: string) => void;
//   age: number;
// }
// type NonFuncNames = NonFunctionPropertyNames<User>;
// 结果: "name" | "age"
```

## 实践练习

### 练习1：泛型约束和条件类型
```typescript
// 任务：创建一个类型安全的API客户端
interface ApiClient<T> {
  get<K extends keyof T>(endpoint: K): Promise<T[K]>;
  post<K extends keyof T>(endpoint: K, data: T[K]): Promise<T[K]>;
}

// 实现 ApiClient 类型
type ApiEndpoints = {
  users: User[];
  posts: Post[];
  comments: Comment[];
};
```

### 练习2：映射类型和模板字面量
```typescript
// 任务：使用映射类型和模板字面量创建新类型

// 1. 使用映射类型将所有属性转换为函数类型
interface User {
  id: number;
  name: string;
  email: string;
}

// 创建一个类型，将 User 的每个属性转换为对应的 setter 函数
// 例如：{ setId: (value: number) => void; setName: (value: string) => void; ... }
type UserSetters<T> = {
  // 你的实现：使用映射类型和模板字面量
};

// 2. 使用条件映射类型过滤属性
// 创建一个类型，只保留 string 类型的属性
type StringPropsOnly<T> = {
  // 你的实现：使用条件映射
};

// 测试类型
type TestUserSetters = UserSetters<User>;
type TestStringProps = StringPropsOnly<User>;
```

### 练习3：条件类型和递归类型
```typescript
// 任务：创建实用的类型工具

// 1. 创建一个条件类型，提取数组或 Promise 的内部类型
// 如果 T 是 Array<U>，返回 U
// 如果 T 是 Promise<U>，返回 U
// 否则返回 T 本身
type Unwrap<T> = 
  // 你的实现：使用条件类型和 infer

// 2. 创建一个递归类型，将对象的所有属性路径提取出来
// 例如：{ a: { b: string; c: number } } => "a" | "a.b" | "a.c"
type ObjectPaths<T> = 
  // 你的实现：使用递归和模板字面量

// 3. 创建一个工具类型，根据路径获取对应的值类型
// 例如：GetByPath<{ a: { b: string } }, "a.b"> => string
type GetByPath<T, P extends string> = 
  // 你的实现：使用条件类型和字符串分割

// 测试用例
type Test1 = Unwrap<Promise<string>>; // 应该是 string
type Test2 = Unwrap<Array<number>>;   // 应该是 number
type Test3 = Unwrap<boolean>;         // 应该是 boolean

interface TestObj {
  user: {
    profile: {
      name: string;
      age: number;
    };
    settings: {
      theme: string;
    };
  };
}

type TestPaths = ObjectPaths<TestObj>; // 应该包含 "user", "user.profile", "user.profile.name" 等
type TestValue = GetByPath<TestObj, "user.profile.name">; // 应该是 string
```

## 学习检查点

- [ ] 能够使用泛型约束和默认值
- [ ] 理解条件类型和推断的使用
- [ ] 掌握映射类型的创建和应用
- [ ] 熟练使用模板字面量类型
- [ ] 能够创建自定义工具类型

## 下一步学习

完成本部分学习后，请继续学习 [1.3 实践练习](./1.3-practice-exercises.md)。
