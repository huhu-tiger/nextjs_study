# 1.1 现代类型系统基础

## 学习目标
- 掌握TypeScript 5.x严格模式配置和最佳实践
- 理解类型推断和类型注解的使用场景
- 熟练使用联合类型、交叉类型和字面量类型
- 掌握类型断言和类型守卫的技巧
- 了解枚举和const断言的应用

## 学习内容

### 1. 严格模式配置和最佳实践

#### 1.1 tsconfig.json 严格配置
```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictBindCallApply": true,
    "strictPropertyInitialization": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true
  }
}
```

#### 1.2 类型推断最佳实践
```typescript
// 让TypeScript推断类型
const user = {
  name: "John",
  age: 30,
  isActive: true
}; // 类型被推断为 { name: string; age: number; isActive: boolean }

// 显式类型注解
const users: Array<{ name: string; age: number }> = [];
const userId: number = 123;
```

### 2. 联合类型、交叉类型和字面量类型

#### 2.1 联合类型 (Union Types)
```typescript
// 基础联合类型
type Status = "loading" | "success" | "error";
type StringOrNumber = string | number;

// 函数参数联合类型
function formatValue(value: string | number): string {
  if (typeof value === "string") {
    return value.toUpperCase();
  }
  return value.toString();
}

// 对象联合类型
type User = {
  type: "admin";
  permissions: string[];
} | {
  type: "user";
  role: string;
};
```

#### 2.2 交叉类型 (Intersection Types)
```typescript
// 基础交叉类型
type Person = {
  name: string;
  age: number;
};

type Employee = {
  id: number;
  department: string;
};

type EmployeePerson = Person & Employee;

// 函数交叉类型
type Logger = {
  log: (message: string) => void;
};

type Timestamped = {
  timestamp: () => number;
};

type TimestampedLogger = Logger & Timestamped;
```

#### 2.3 字面量类型 (Literal Types)
```typescript
// 字符串字面量类型
type Theme = "light" | "dark" | "auto";
type HttpMethod = "GET" | "POST" | "PUT" | "DELETE";

// 数字字面量类型
type DiceRoll = 1 | 2 | 3 | 4 | 5 | 6;

// 布尔字面量类型
type Success = true;
type Failure = false;

// 对象字面量类型
const config = {
  apiUrl: "https://api.example.com",
  timeout: 5000,
  retries: 3
} as const; // 使用 const 断言
```

### 3. 类型断言和类型守卫

#### 3.1 类型断言 (Type Assertions)
```typescript
// 基础类型断言
const userInput = "123";
const userId = userInput as number; // 不推荐，可能不安全

// 更安全的类型断言
const userInput2 = "123";
const userId2 = parseInt(userInput2) as number;

// 使用 angle bracket 语法
const userInput3 = "123";
const userId3 = <number>parseInt(userInput3);

// DOM 元素类型断言
const button = document.getElementById("submit") as HTMLButtonElement;
const input = document.querySelector("input") as HTMLInputElement;
```

#### 3.2 类型守卫 (Type Guards)
```typescript
// 基础类型守卫
function isString(value: unknown): value is string {
  return typeof value === "string";
}

function isNumber(value: unknown): value is number {
  return typeof value === "number";
}

// 使用类型守卫
function processValue(value: unknown) {
  if (isString(value)) {
    // 在这个块中，value 被推断为 string 类型
    console.log(value.toUpperCase());
  } else if (isNumber(value)) {
    // 在这个块中，value 被推断为 number 类型
    console.log(value.toFixed(2));
  }
}

// 对象类型守卫
interface User {
  name: string;
  email: string;
}

function isUser(obj: unknown): obj is User {
  return (
    typeof obj === "object" &&
    obj !== null &&
    "name" in obj &&
    "email" in obj &&
    typeof (obj as any).name === "string" &&
    typeof (obj as any).email === "string"
  );
}
```

### 4. 枚举和const断言

#### 4.1 枚举 (Enums)
```typescript
// 数字枚举
enum Status {
  Pending,
  Approved,
  Rejected
}

// 字符串枚举
enum Color {
  Red = "red",
  Green = "green",
  Blue = "blue"
}

// 混合枚举
enum Mixed {
  No = 0,
  Yes = "yes"
}

// const 枚举 (编译时内联)
const enum Direction {
  Up,
  Down,
  Left,
  Right
}
```

#### 4.2 const断言 (const assertions)
```typescript
// 数组 const 断言
const colors = ["red", "green", "blue"] as const;
// 类型: readonly ["red", "green", "blue"]

// 对象 const 断言
const config = {
  apiUrl: "https://api.example.com",
  timeout: 5000,
  retries: 3
} as const;
// 类型: { readonly apiUrl: "https://api.example.com"; readonly timeout: 5000; readonly retries: 3; }

// 函数 const 断言
const createUser = (name: string, age: number) => ({ name, age }) as const;
// 返回类型: { readonly name: string; readonly age: number; }
```

## 实践练习

### 练习1：类型推断和注解
```typescript
// 任务：为以下代码添加适当的类型注解
const products = [
  { id: 1, name: "Laptop", price: 999.99, inStock: true },
  { id: 2, name: "Mouse", price: 29.99, inStock: false }
];

function calculateTotal(products: /* 你的类型注解 */) {
  return products.reduce((total, product) => total + product.price, 0);
}
```

### 练习2：联合类型和类型守卫
```typescript
// 任务：创建一个函数，处理不同类型的用户输入
type UserInput = string | number | boolean;

function processUserInput(input: UserInput): string {
  // 实现类型守卫和处理逻辑
}
```

### 练习3：字面量类型和const断言
```typescript
// 任务：创建一个主题配置，使用字面量类型和const断言
const themeConfig = {
  primary: "blue",
  secondary: "gray",
  mode: "light"
} as const;

// 基于 themeConfig 创建类型
type ThemeConfig = typeof themeConfig;
```

## 学习检查点

- [ ] 能够配置TypeScript严格模式
- [ ] 理解类型推断和类型注解的区别
- [ ] 熟练使用联合类型和交叉类型
- [ ] 掌握类型断言和类型守卫的使用
- [ ] 了解枚举和const断言的应用场景

## 下一步学习

完成本部分学习后，请继续学习 [1.2 高级类型编程](./1.2-advanced-types.md)。
