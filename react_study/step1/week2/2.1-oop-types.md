# 2.1 面向对象编程类型支持

## 学习目标
- 掌握类和接口设计模式
- 理解继承、多态和组合的类型支持
- 熟练使用抽象类和接口
- 了解装饰器和元编程
- 掌握面向对象编程的最佳实践

## 学习内容

### 1. 类和接口设计模式

#### 1.1 基础类和接口
```typescript
// 基础接口定义
interface Drawable {
  draw(): void;
  getArea(): number;
}

interface Movable {
  move(x: number, y: number): void;
  getPosition(): { x: number; y: number };
}

// 基础类实现
class Shape implements Drawable {
  protected x: number;
  protected y: number;
  protected color: string;

  constructor(x: number, y: number, color: string) {
    this.x = x;
    this.y = y;
    this.color = color;
  }

  draw(): void {
    console.log(`Drawing shape at (${this.x}, ${this.y}) with color ${this.color}`);
  }

  getArea(): number {
    return 0; // 基础形状面积为0
  }

  getPosition(): { x: number; y: number } {
    return { x: this.x, y: this.y };
  }
}
```

#### 1.2 继承和多态
```typescript
// 继承示例
class Circle extends Shape implements Movable {
  private radius: number;

  constructor(x: number, y: number, color: string, radius: number) {
    super(x, y, color);
    this.radius = radius;
  }

  draw(): void {
    console.log(`Drawing circle at (${this.x}, ${this.y}) with radius ${this.radius}`);
  }

  getArea(): number {
    return Math.PI * this.radius * this.radius;
  }

  move(x: number, y: number): void {
    this.x += x;
    this.y += y;
  }

  getPosition(): { x: number; y: number } {
    return { x: this.x, y: this.y };
  }
}

class Rectangle extends Shape implements Movable {
  private width: number;
  private height: number;

  constructor(x: number, y: number, color: string, width: number, height: number) {
    super(x, y, color);
    this.width = width;
    this.height = height;
  }

  draw(): void {
    console.log(`Drawing rectangle at (${this.x}, ${this.y}) with size ${this.width}x${this.height}`);
  }

  getArea(): number {
    return this.width * this.height;
  }

  move(x: number, y: number): void {
    this.x += x;
    this.y += y;
  }

  getPosition(): { x: number; y: number } {
    return { x: this.x, y: this.y };
  }
}

// 多态使用
function drawShapes(shapes: Drawable[]): void {
  shapes.forEach(shape => {
    shape.draw();
    console.log(`Area: ${shape.getArea()}`);
  });
}

const shapes: Drawable[] = [
  new Circle(0, 0, "red", 5),
  new Rectangle(10, 10, "blue", 8, 6)
];

drawShapes(shapes);
```

#### 1.3 组合模式
```typescript
// 组合模式示例
interface Component {
  operation(): string;
}

class Leaf implements Component {
  private name: string;

  constructor(name: string) {
    this.name = name;
  }

  operation(): string {
    return this.name;
  }
}

class Composite implements Component {
  private children: Component[] = [];
  private name: string;

  constructor(name: string) {
    this.name = name;
  }

  add(component: Component): void {
    this.children.push(component);
  }

  remove(component: Component): void {
    const index = this.children.indexOf(component);
    if (index > -1) {
      this.children.splice(index, 1);
    }
  }

  operation(): string {
    const results = this.children.map(child => child.operation());
    return `${this.name}(${results.join(', ')})`;
  }
}

// 使用组合模式
const root = new Composite("Root");
const branch1 = new Composite("Branch1");
const branch2 = new Composite("Branch2");

branch1.add(new Leaf("Leaf1"));
branch1.add(new Leaf("Leaf2"));
branch2.add(new Leaf("Leaf3"));

root.add(branch1);
root.add(branch2);

console.log(root.operation()); // Root(Branch1(Leaf1, Leaf2), Branch2(Leaf3))
```

### 2. 抽象类和接口

#### 2.1 抽象类
```typescript
// 抽象类定义
abstract class Animal {
  protected name: string;
  protected age: number;

  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }

  // 具体方法
  getName(): string {
    return this.name;
  }

  getAge(): number {
    return this.age;
  }

  // 抽象方法
  abstract makeSound(): string;
  abstract move(): string;
}

// 抽象类实现
class Dog extends Animal {
  private breed: string;

  constructor(name: string, age: number, breed: string) {
    super(name, age);
    this.breed = breed;
  }

  makeSound(): string {
    return "Woof!";
  }

  move(): string {
    return "Running";
  }

  getBreed(): string {
    return this.breed;
  }
}

class Cat extends Animal {
  private isIndoor: boolean;

  constructor(name: string, age: number, isIndoor: boolean) {
    super(name, age);
    this.isIndoor = isIndoor;
  }

  makeSound(): string {
    return "Meow!";
  }

  move(): string {
    return this.isIndoor ? "Walking indoors" : "Climbing trees";
  }

  getIsIndoor(): boolean {
    return this.isIndoor;
  }
}
```

#### 2.2 接口继承和实现
```typescript
// 基础接口
interface Flyable {
  fly(): string;
  getAltitude(): number;
}

interface Swimmable {
  swim(): string;
  getDepth(): number;
}

// 接口继承
interface Duck extends Flyable, Swimmable {
  quack(): string;
}

// 接口实现
class MallardDuck implements Duck {
  private altitude: number = 0;
  private depth: number = 0;

  fly(): string {
    this.altitude = 100;
    return "Flying high!";
  }

  getAltitude(): number {
    return this.altitude;
  }

  swim(): string {
    this.depth = 5;
    return "Swimming deep!";
  }

  getDepth(): number {
    return this.depth;
  }

  quack(): string {
    return "Quack quack!";
  }
}

// 多重接口实现
class FlyingFish implements Flyable, Swimmable {
  private altitude: number = 0;
  private depth: number = 0;

  fly(): string {
    this.altitude = 50;
    return "Gliding above water!";
  }

  getAltitude(): number {
    return this.altitude;
  }

  swim(): string {
    this.depth = 20;
    return "Swimming in the ocean!";
  }

  getDepth(): number {
    return this.depth;
  }
}
```

### 3. 装饰器和元编程

#### 3.1 类装饰器
```typescript
// 类装饰器
function sealed(constructor: Function) {
  Object.seal(constructor);
  Object.seal(constructor.prototype);
}

function logged(constructor: Function) {
  console.log(`Class ${constructor.name} is being defined`);
}

@sealed
@logged
class Greeter {
  greeting: string;

  constructor(message: string) {
    this.greeting = message;
  }

  greet() {
    return "Hello, " + this.greeting;
  }
}
```

#### 3.2 方法装饰器
```typescript
// 方法装饰器
function enumerable(value: boolean) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    descriptor.enumerable = value;
  };
}

function readonly(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  descriptor.writable = false;
}

class Example {
  @enumerable(false)
  @readonly
  method() {
    return "This method is not enumerable and readonly";
  }
}
```

#### 3.3 属性装饰器
```typescript
// 属性装饰器
function format(formatString: string) {
  return function (target: any, propertyKey: string) {
    let value = target[propertyKey];

    const getter = function () {
      return value;
    };

    const setter = function (newVal: any) {
      value = formatString.replace('%s', newVal);
    };

    Object.defineProperty(target, propertyKey, {
      get: getter,
      set: setter,
      enumerable: true,
      configurable: true
    });
  };
}

class User {
  @format('Hello, %s!')
  greeting: string = 'World';
}

const user = new User();
console.log(user.greeting); // "Hello, World!"
```

#### 3.4 参数装饰器
```typescript
// 参数装饰器
function validate(target: any, propertyKey: string, parameterIndex: number) {
  const existingRequiredParameters: number[] = Reflect.getOwnMetadata('required', target, propertyKey) || [];
  existingRequiredParameters.push(parameterIndex);
  Reflect.defineMetadata('required', existingRequiredParameters, target, propertyKey);
}

function required(target: any, propertyKey: string, parameterIndex: number) {
  const existingRequiredParameters: number[] = Reflect.getOwnMetadata('required', target, propertyKey) || [];
  existingRequiredParameters.push(parameterIndex);
  Reflect.defineMetadata('required', existingRequiredParameters, target, propertyKey);
}

class Example {
  method(@required name: string, @validate age: number) {
    return `Name: ${name}, Age: ${age}`;
  }
}
```

### 4. 高级面向对象模式

#### 4.1 工厂模式
```typescript
// 工厂模式
interface Product {
  operation(): string;
}

class ConcreteProductA implements Product {
  operation(): string {
    return "ConcreteProductA";
  }
}

class ConcreteProductB implements Product {
  operation(): string {
    return "ConcreteProductB";
  }
}

abstract class Creator {
  abstract factoryMethod(): Product;

  someOperation(): string {
    const product = this.factoryMethod();
    return `Creator: ${product.operation()}`;
  }
}

class ConcreteCreatorA extends Creator {
  factoryMethod(): Product {
    return new ConcreteProductA();
  }
}

class ConcreteCreatorB extends Creator {
  factoryMethod(): Product {
    return new ConcreteProductB();
  }
}

// 使用工厂模式
function clientCode(creator: Creator) {
  console.log(creator.someOperation());
}

clientCode(new ConcreteCreatorA());
clientCode(new ConcreteCreatorB());
```

#### 4.2 单例模式
```typescript
// 单例模式
class Singleton {
  private static instance: Singleton;
  private data: string;

  private constructor(data: string) {
    this.data = data;
  }

  public static getInstance(data: string): Singleton {
    if (!Singleton.instance) {
      Singleton.instance = new Singleton(data);
    }
    return Singleton.instance;
  }

  public getData(): string {
    return this.data;
  }

  public setData(data: string): void {
    this.data = data;
  }
}

// 使用单例模式
const singleton1 = Singleton.getInstance("First instance");
const singleton2 = Singleton.getInstance("Second instance");

console.log(singleton1.getData()); // "First instance"
console.log(singleton2.getData()); // "First instance"
console.log(singleton1 === singleton2); // true
```

#### 4.3 观察者模式
```typescript
// 观察者模式
interface Observer {
  update(subject: Subject): void;
}

interface Subject {
  attach(observer: Observer): void;
  detach(observer: Observer): void;
  notify(): void;
}

class ConcreteSubject implements Subject {
  private observers: Observer[] = [];
  private state: number = 0;

  public attach(observer: Observer): void {
    this.observers.push(observer);
  }

  public detach(observer: Observer): void {
    const index = this.observers.indexOf(observer);
    if (index > -1) {
      this.observers.splice(index, 1);
    }
  }

  public notify(): void {
    this.observers.forEach(observer => observer.update(this));
  }

  public setState(state: number): void {
    this.state = state;
    this.notify();
  }

  public getState(): number {
    return this.state;
  }
}

class ConcreteObserver implements Observer {
  private name: string;

  constructor(name: string) {
    this.name = name;
  }

  public update(subject: Subject): void {
    console.log(`${this.name} received update: ${(subject as ConcreteSubject).getState()}`);
  }
}

// 使用观察者模式
const subject = new ConcreteSubject();
const observer1 = new ConcreteObserver("Observer 1");
const observer2 = new ConcreteObserver("Observer 2");

subject.attach(observer1);
subject.attach(observer2);

subject.setState(10); // 两个观察者都会收到通知
```

## 实践练习

### 练习1：设计模式实现
```typescript
// 任务：实现策略模式
interface PaymentStrategy {
  pay(amount: number): string;
}

class CreditCardPayment implements PaymentStrategy {
  pay(amount: number): string {
    return `Paid $${amount} using Credit Card`;
  }
}

class PayPalPayment implements PaymentStrategy {
  pay(amount: number): string {
    return `Paid $${amount} using PayPal`;
  }
}

class PaymentProcessor {
  private strategy: PaymentStrategy;

  constructor(strategy: PaymentStrategy) {
    this.strategy = strategy;
  }

  setStrategy(strategy: PaymentStrategy): void {
    this.strategy = strategy;
  }

  processPayment(amount: number): string {
    return this.strategy.pay(amount);
  }
}

// 使用策略模式
const processor = new PaymentProcessor(new CreditCardPayment());
console.log(processor.processPayment(100));

processor.setStrategy(new PayPalPayment());
console.log(processor.processPayment(200));
```

### 练习2：装饰器应用
```typescript
// 任务：创建性能监控装饰器
function performance(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;

  descriptor.value = function (...args: any[]) {
    const start = performance.now();
    const result = originalMethod.apply(this, args);
    const end = performance.now();
    console.log(`${propertyKey} took ${end - start} milliseconds`);
    return result;
  };

  return descriptor;
}

class Calculator {
  @performance
  heavyCalculation(n: number): number {
    let result = 0;
    for (let i = 0; i < n; i++) {
      result += Math.sqrt(i);
    }
    return result;
  }
}
```

### 练习3：接口组合
```typescript
// 任务：创建可配置的组件系统
interface Configurable {
  configure(config: any): void;
  getConfiguration(): any;
}

interface Renderable {
  render(): string;
}

interface Validatable {
  validate(): boolean;
  getErrors(): string[];
}

// 创建组合接口
interface Component extends Configurable, Renderable, Validatable {
  name: string;
}

// 实现组件
class FormField implements Component {
  name: string;
  private config: any = {};
  private errors: string[] = [];

  constructor(name: string) {
    this.name = name;
  }

  configure(config: any): void {
    this.config = { ...this.config, ...config };
  }

  getConfiguration(): any {
    return this.config;
  }

  render(): string {
    return `<input name="${this.name}" type="${this.config.type || 'text'}" />`;
  }

  validate(): boolean {
    this.errors = [];
    if (this.config.required && !this.config.value) {
      this.errors.push(`${this.name} is required`);
    }
    return this.errors.length === 0;
  }

  getErrors(): string[] {
    return this.errors;
  }
}
```

## 学习检查点

- [ ] 能够设计和使用类和接口
- [ ] 理解继承、多态和组合的区别
- [ ] 掌握抽象类和接口的使用
- [ ] 了解装饰器的基本用法
- [ ] 能够实现常见的设计模式

## 下一步学习

完成本部分学习后，请继续学习 [2.2 函数式编程类型支持](./2.2-functional-types.md)。
