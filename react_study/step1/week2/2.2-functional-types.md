# 2.2 函数式编程类型支持

## 学习目标
- 掌握TypeScript中函数式编程的类型支持
- 理解高阶函数的类型定义
- 熟练使用函数组合和柯里化
- 了解函数式编程模式在TypeScript中的应用

## 学习内容

### 1. 函数类型基础

#### 1.1 函数类型定义
```typescript
// 基础函数类型
type SimpleFunction = () => void;
type StringFunction = (str: string) => string;
type NumberFunction = (a: number, b: number) => number;

// 函数接口
interface MathOperation {
  (a: number, b: number): number;
}

// 泛型函数类型
type GenericFunction<T, R> = (arg: T) => R;

// 可选参数和默认参数
type OptionalParams = (a: number, b?: number, c?: string) => number;
type DefaultParams = (a: number, b: number = 10) => number;

// 剩余参数
type RestParams = (...args: number[]) => number;
```

#### 1.2 函数重载
```typescript
// 函数重载
function process(value: string): string;
function process(value: number): number;
function process(value: boolean): boolean;
function process(value: string | number | boolean): string | number | boolean {
  if (typeof value === 'string') {
    return value.toUpperCase();
  } else if (typeof value === 'number') {
    return value * 2;
  } else {
    return !value;
  }
}

// 构造函数重载
class Point {
  x: number;
  y: number;

  constructor(x: number, y: number);
  constructor(point: { x: number; y: number });
  constructor(xOrPoint: number | { x: number; y: number }, y?: number) {
    if (typeof xOrPoint === 'number') {
      this.x = xOrPoint;
      this.y = y!;
    } else {
      this.x = xOrPoint.x;
      this.y = xOrPoint.y;
    }
  }
}
```

### 2. 高阶函数类型

#### 2.1 基础高阶函数
```typescript
// 接受函数作为参数
type HigherOrderFunction<T, R> = (fn: (arg: T) => R) => (arg: T) => R;

// 返回函数的函数
type FunctionFactory<T, R> = (config: any) => (arg: T) => R;

// 实际应用
function withLogging<T extends (...args: any[]) => any>(
  fn: T
): (...args: Parameters<T>) => ReturnType<T> {
  return (...args: Parameters<T>): ReturnType<T> => {
    console.log(`Calling function with args:`, args);
    const result = fn(...args);
    console.log(`Function returned:`, result);
    return result;
  };
}

// 使用示例
const add = (a: number, b: number) => a + b;
const loggedAdd = withLogging(add);
const result = loggedAdd(2, 3); // 输出日志并返回5
```

#### 2.2 函数组合
```typescript
// 函数组合类型
type Compose<A, B, C> = (f: (b: B) => C, g: (a: A) => B) => (a: A) => C;

// 函数组合实现
function compose<A, B, C>(
  f: (b: B) => C,
  g: (a: A) => B
): (a: A) => C {
  return (a: A) => f(g(a));
}

// 多函数组合
type ComposeMany<T extends any[]> = T extends [infer F, ...infer R]
  ? F extends (...args: any[]) => any
    ? R extends []
      ? F
      : F extends (...args: any[]) => infer U
      ? ComposeMany<R> extends (...args: any[]) => U
        ? ComposeMany<R>
        : never
      : never
    : never
  : never;

// 管道操作
type Pipe<A, B, C> = (a: A, f: (a: A) => B, g: (b: B) => C) => C;

function pipe<A, B, C>(
  a: A,
  f: (a: A) => B,
  g: (b: B) => C
): C {
  return g(f(a));
}
```

### 3. 柯里化和偏应用

#### 3.1 柯里化类型
```typescript
// 柯里化类型定义
type Curry<A extends any[], R> = A extends [infer H, ...infer T]
  ? (arg: H) => Curry<T, R>
  : R;

// 柯里化实现
function curry<A extends any[], R>(
  fn: (...args: A) => R
): Curry<A, R> {
  return ((...args: any[]) => {
    if (args.length >= fn.length) {
      return fn(...args as A);
    }
    return curry(fn.bind(null, ...args));
  }) as Curry<A, R>;
}

// 使用示例
const add = (a: number, b: number, c: number) => a + b + c;
const curriedAdd = curry(add);
const add5 = curriedAdd(5);
const add5And3 = add5(3);
const result = add5And3(2); // 10
```

#### 3.2 偏应用
```typescript
// 偏应用类型
type PartialApply<A extends any[], R> = <T extends Partial<A>>(
  ...args: T
) => T extends A ? R : PartialApply<A, R>;

// 偏应用实现
function partial<A extends any[], R>(
  fn: (...args: A) => R,
  ...partialArgs: Partial<A>
): (...args: A) => R {
  return (...args: A) => {
    const allArgs = [...partialArgs, ...args] as A;
    return fn(...allArgs);
  };
}

// 使用示例
const multiply = (a: number, b: number, c: number) => a * b * c;
const multiplyBy2 = partial(multiply, 2);
const result = multiplyBy2(3, 4); // 2 * 3 * 4 = 24
```

### 4. 函数式编程模式

#### 4.1 Maybe类型
```typescript
// Maybe类型定义
type Maybe<T> = T | null | undefined;

// Maybe工具函数
function isSome<T>(value: Maybe<T>): value is T {
  return value !== null && value !== undefined;
}

function isNone<T>(value: Maybe<T>): value is null | undefined {
  return value === null || value === undefined;
}

// Maybe操作函数
function map<T, U>(
  value: Maybe<T>,
  fn: (value: T) => U
): Maybe<U> {
  return isSome(value) ? fn(value) : value;
}

function flatMap<T, U>(
  value: Maybe<T>,
  fn: (value: T) => Maybe<U>
): Maybe<U> {
  return isSome(value) ? fn(value) : value;
}

// 使用示例
const maybeNumber: Maybe<number> = 42;
const doubled = map(maybeNumber, x => x * 2);
const squared = map(doubled, x => x * x);
```

#### 4.2 Either类型
```typescript
// Either类型定义
type Either<L, R> = { kind: 'left'; value: L } | { kind: 'right'; value: R };

// Either工具函数
function left<L, R>(value: L): Either<L, R> {
  return { kind: 'left', value };
}

function right<L, R>(value: R): Either<L, R> {
  return { kind: 'right', value };
}

function isLeft<L, R>(either: Either<L, R>): either is { kind: 'left'; value: L } {
  return either.kind === 'left';
}

function isRight<L, R>(either: Either<L, R>): either is { kind: 'right'; value: R } {
  return either.kind === 'right';
}

// Either操作函数
function map<L, R, U>(
  either: Either<L, R>,
  fn: (value: R) => U
): Either<L, U> {
  return isRight(either) ? right(fn(either.value)) : either;
}

function flatMap<L, R, U>(
  either: Either<L, R>,
  fn: (value: R) => Either<L, U>
): Either<L, U> {
  return isRight(either) ? fn(either.value) : either;
}
```

#### 4.3 函数式数组操作
```typescript
// 函数式数组操作类型
type ArrayOperation<T, U> = (array: T[]) => U[];

// 基础操作
const map = <T, U>(fn: (item: T) => U): ArrayOperation<T, U> => 
  (array: T[]) => array.map(fn);

const filter = <T>(predicate: (item: T) => boolean): ArrayOperation<T, T> => 
  (array: T[]) => array.filter(predicate);

const reduce = <T, U>(
  reducer: (acc: U, item: T) => U,
  initial: U
): (array: T[]) => U => 
  (array: T[]) => array.reduce(reducer, initial);

// 组合操作
const compose = <T, U, V>(
  f: ArrayOperation<U, V>,
  g: ArrayOperation<T, U>
): ArrayOperation<T, V> => 
  (array: T[]) => f(g(array));

// 使用示例
const numbers = [1, 2, 3, 4, 5];
const double = map<number, number>(x => x * 2);
const isEven = filter<number>(x => x % 2 === 0);
const sum = reduce<number, number>((acc, x) => acc + x, 0);

const evenNumbers = isEven(numbers);
const doubledEvens = double(evenNumbers);
const sumOfDoubledEvens = sum(doubledEvens);
```

### 5. 函数式编程工具类型

#### 5.1 函数工具类型
```typescript
// 函数参数类型
type Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never;

// 函数返回类型
type ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any;

// 函数this类型
type ThisParameterType<T> = T extends (this: infer U, ...args: any[]) => any ? U : unknown;

// 移除this参数
type OmitThisParameter<T> = T extends (this: any, ...args: infer P) => infer R ? (...args: P) => R : T;

// 函数重载类型
type Overloads<T> = T extends {
  (...args: infer A1): infer R1;
  (...args: infer A2): infer R2;
  (...args: infer A3): infer R3;
  (...args: infer A4): infer R4;
} ? [A1, A2, A3, A4] : never;
```

#### 5.2 函数式编程工具
```typescript
// 函数组合工具
type Compose<A, B, C> = (f: (b: B) => C, g: (a: A) => B) => (a: A) => C;

// 管道工具
type Pipe<A, B, C> = (a: A, f: (a: A) => B, g: (b: B) => C) => C;

// 柯里化工具
type Curry<A extends any[], R> = A extends [infer H, ...infer T]
  ? (arg: H) => Curry<T, R>
  : R;

// 偏应用工具
type PartialApply<A extends any[], R> = <T extends Partial<A>>(
  ...args: T
) => T extends A ? R : PartialApply<A, R>;
```

## 实践练习

### 练习1：函数组合实现
```typescript
// 任务：实现函数组合工具
function compose<A, B, C>(
  f: (b: B) => C,
  g: (a: A) => B
): (a: A) => C {
  // 你的实现
}

// 测试用例
const add1 = (x: number) => x + 1;
const multiply2 = (x: number) => x * 2;
const toString = (x: number) => x.toString();

const composed = compose(compose(toString, multiply2), add1);
const result = composed(5); // 应该是 "12"
```

### 练习2：Maybe类型实现
```typescript
// 任务：实现完整的Maybe类型
class Maybe<T> {
  private constructor(private value: T | null) {}

  static some<T>(value: T): Maybe<T> {
    // 你的实现
  }

  static none<T>(): Maybe<T> {
    // 你的实现
  }

  map<U>(fn: (value: T) => U): Maybe<U> {
    // 你的实现
  }

  flatMap<U>(fn: (value: T) => Maybe<U>): Maybe<U> {
    // 你的实现
  }

  getOrElse(defaultValue: T): T {
    // 你的实现
  }
}
```

### 练习3：函数式数组操作
```typescript
// 任务：实现函数式数组操作
class FunctionalArray<T> {
  constructor(private array: T[]) {}

  map<U>(fn: (item: T) => U): FunctionalArray<U> {
    // 你的实现
  }

  filter(predicate: (item: T) => boolean): FunctionalArray<T> {
    // 你的实现
  }

  reduce<U>(reducer: (acc: U, item: T) => U, initial: U): U {
    // 你的实现
  }

  toArray(): T[] {
    // 你的实现
  }
}
```

## 学习检查点

- [ ] 能够定义和使用函数类型
- [ ] 理解高阶函数的类型支持
- [ ] 掌握函数组合和柯里化
- [ ] 了解函数式编程模式
- [ ] 能够实现函数式编程工具

## 下一步学习

完成本部分学习后，请继续学习 [2.3 实践练习](./2.3-practice-exercises.md)。
