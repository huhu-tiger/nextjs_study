{"version":3,"file":"bundle.js","sources":["../src/index.ts"],"sourcesContent":["// 泛型可以 用于 函数 类 接口 类型别名\n// 无法确定泛型类型 可以 使用 泛型约束\n\nconst createArr = <T>(times: T, val: T[]): T[] => {\n    let abc = val.map(item => {\n        return item;\n    });\n    return abc\n}\n\nconst arr1 = createArr(\"q\", ['a'])\n\n\n\n// 泛型约束\n// 1. 泛型约束 可以 约束 泛型 的类型\ninterface ILength{\n    length:number\n}\n\nconst getLength = <T extends ILength>(arg:T):number=>{\n    return arg.length\n}\n\ngetLength(\"123\")\ngetLength({length:123})\n\n\n// 2. 泛型约束 \nconst fnn1 = <T ,key extends keyof T>(arg:T,key1:key):T[key]=>{\n    return arg[key1]\n}\n\nlet obj111  = {\n    name:\"123\",\n    age:123\n}\n\nconsole.log(fnn1(obj111,\"name\"))\nconsole.log(fnn1(\"dddd\",\"length\")) // 4, 字符串 有 length 属性\nconsole.log(fnn1([\"abc\",\"bn\"],1))    //  bn, 1 代表索引位置\n\n// 写辅助函数\n// 值的交换,T,U 名字自定义\nconst swap = <T, U>(tuple: [T, U]): [U, T] => {\n    return [tuple[1], tuple[0]]\n}\n\nconst swapArr = swap(['a', 1])\n\n// 接口泛型\n\ninterface IArr<T>{\n    a:T\n    arr:T[]\n}\n\nlet arr111:IArr<number> = {\n    a:1,\n    arr:[1,2,3]\n}\n\n// 泛型类\n\nclass MyArray<T>{\n    private arr:T[] = []\n    add(item:T){\n        this.arr.push(item)\n    }\n    \n}\nconst m = new MyArray<number>()\n\n\n// 泛型工具类型\n/*\nPartial<T> 将 T 的属性变为可选\nRequired<T> 将 T 的属性变为必选\nReadonly<T> 将 T 的属性变为只读\nPick<T,K extends keyof T> 从 T 中选择一组属性\nOmit<T,K extends keyof T> 从 T 中移除一组属性\nExtract<T,U> 提取 T 中可以赋值给 U 的类型\n*/\n\n// 1. Partial<T> 将 T 的属性变为可选\ninterface IPartial{\n    name:string\n    age:number\n}\n\ntype IPartial1 = Partial<IPartial> //变成可选\n// type IPartial1 = {\n//     name?:string\n//     age?:number\n// }\n// 2. readonly 将 T 的属性变为只读\ntype IReadonly = Readonly<IPartial>\n// type IReadonly = {\n//     readonly name:string\n//     readonly age:number\n// }\n\n// 3. Pick<T,K extends keyof T> 从 T 中选择一组属性\ntype IPick = Pick<IPartial, \"name\"|\"age\">\n// type IPick = {\n//     name:string\n//     age:number\n// }\n\n// 4. Omit<T,K extends keyof T> 从 T 中移除一组属性\ntype IOmit = Required<Omit<IPartial, \"name\">>\n// type IOmit = {\n//     age:number\n// }\n\n// 5. Required<T> 将 T 的属性变为必选\ntype IRequired = Required<Omit<IPartial, \"name\">> // 移动了 name 属性，剩下age 必选\n// type IRequired = {\n//     age:number\n// }\n\n// 6. Record<K extends keyof any,T> 将 K 的属性变为 T 类型\ntype IRecord = Record<\"name\"|\"age\",string> // 将 name 和 age 的属性变为 string 类型\n// type IRecord = {\n//     name:string\n//     age:string\n// }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],"names":[],"mappings":";;;IAoBA,MAAM,SAAS,GAAG,CAAoB,GAAK,KAAU;QACjD,OAAO,GAAG,CAAC,MAAM;IACrB,CAAC;IAED,SAAS,CAAC,KAAK,CAAC;IAChB,SAAS,CAAC,EAAC,MAAM,EAAC,GAAG,EAAC,CAAC;IAGvB;IACA,MAAM,IAAI,GAAG,CAAyB,GAAK,EAAC,IAAQ,KAAU;IAC1D,IAAA,OAAO,GAAG,CAAC,IAAI,CAAC;IACpB,CAAC;IAED,IAAI,MAAM,GAAI;IACV,IAAA,IAAI,EAAC,KAAK;IACV,IAAA,GAAG,EAAC;KACP;IAED,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,EAAC,MAAM,CAAC,CAAC;IAChC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,EAAC,QAAQ,CAAC,CAAC,CAAA;IAClC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,KAAK,EAAC,IAAI,CAAC,EAAC,CAAC,CAAC,CAAC,CAAA;IAmFjC;IACA;IACA;IACA;;;;;;"}